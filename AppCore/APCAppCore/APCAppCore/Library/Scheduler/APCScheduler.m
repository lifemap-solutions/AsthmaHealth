// 
//  APCScheduler.m 
//  APCAppCore 
// 
//  Copyright (c) 2015, Apple Inc. All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1.  Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//  2.  Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation and/or
//  other materials provided with the distribution.
//
//  3.  Neither the name of the copyright holder(s) nor the names of any contributors
//  may be used to endorse or promote products derived from this software without
//  specific prior written permission. No license is granted to the trademarks of
//  the copyright holders even if such marks are included in this software.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
 

#import "APCScheduler.h"

#import "APCAppDelegate.h"
#import "APCDataSubstrate.h"
#import "APCDateRange.h"
#import "APCGenericSurveyTaskViewController.h"
#import "APCPotentialScheduledTask.h"
#import "APCSchedule+AddOn.h"
#import "APCScheduleDebugPrinter.h"
#import "APCTask+AddOn.h"
#import "APCTaskGroup.h"
#import "APCTaskGroupCacheEntry.h"
#import "APCTopLevelScheduleEnumerator.h"
#import "APCUser.h"
#import "APCUtilities.h"
#import "NSArray+APCHelper.h"
#import "NSDate+Helper.h"
#import "NSDictionary+APCAdditions.h"
#import "NSOperationQueue+Helper.h"
#import "SBBSchedule+APCHelper.h"


/**
 Controls whether we compute and show (very) detailed debugging
 printouts.  This will always be NO in a release build.
 */
static BOOL const kAPCShowDebugPrintouts = YES;

/** If we import multiple tasks with an ID of "null,"
 this value will appear in the list of duplicate IDs. */
static NSString * const kAPCNullTaskIdString = @"(this task ID was null)";


/**
 Location of the static tasks-and-schedules file on disk,
 and dictionary keys in that file.
 */
static NSString * const kAPCStaticJSONTasksAndSchedulesFileName      = @"APHTasksAndSchedules.json";
static NSString * const kAPCStaticJSONTasksAndSchedulesSchedulesKey  = @"schedules";
static NSString * const kAPCStaticJSONTasksAndSchedulesTasksKey      = @"tasks";            // Deprecated.


/**
 Error codes and messages generated by this class.
 Please alphabetize.
 */
typedef enum : NSUInteger {
    APCErrorCouldntFetchActiveSchedulesForDateCode,
    APCErrorCouldntFetchVisibleSchedulesForDateCode,
    APCErrorCouldntFindSurveyFileCode,
    APCErrorDeletingTaskCode,
    APCErrorInboundListOfSchedulesAndTasksIssuesCode,
    APCErrorJSONTasksAndScheduleIsNotAnArrayCode,
    APCErrorJSONTasksAndSchedulesIsEmptyCode,
    APCErrorJSONTasksAndSchedulesNilValueForKeyCode,
    APCErrorLoadingJsonFromDiskCode,
    APCErrorLoadingJsonNoDictionaryCode,
    APCErrorLoadingNativeBridgeSurveyObjectCode,
    APCErrorLoadingSurveyFileCode,
    APCErrorMoreThanOneScheduleWithSameTaskIDCode,
    APCErrorMoreThanOneTaskWithIdAndVersionCode,
    APCErrorParsingSurveyContentCode,
    APCErrorSavingEverythingCode,
    APCErrorSavingToPeristentStoreCode,
    APCErrorSearchingForTaskWithIDCode,
    APCErrorServerDisabledCode,
    APCErrorTooManyTasksWithSameIDCode
}   APCError;

static NSString * const APCErrorDomainLoadingTasksAndSchedules                      = @"kAPCErrorDomainLoadingTasksAndSchedules";

static NSString * const APCErrorCouldntFetchActiveSchedulesForDateReason            = @"Couldn't fetch active schedules for given date";
static NSString * const APCErrorCouldntFetchActiveSchedulesForDateSuggestion        = @"There was an error executing a fetch request for active APCSchedules with this date.";
static NSString * const APCErrorCouldntFetchVisibleSchedulesForDateReason           = @"Couldn't fetch visible schedules for given date";
static NSString * const APCErrorCouldntFetchVisibleSchedulesForDateSuggestion       = @"There was an error executing a fetch request for visible APCSchedules with this date.";
static NSString * const APCErrorCouldntFindSurveyFileReason                         = @"Can't Find Survey File";
static NSString * const APCErrorCouldntFindSurveyFileSuggestion                     = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorDeletingTaskReason                                  = @"Error attempting to delete task.";
static NSString * const APCErrorDeletingTaskSuggestion                              = @"Error attempting to delete task. This may give the user unexpected results.";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesReason          = @"Inbound list of schedules and task have issues";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion      = @"Inbound list of schedules and task ID's or versions conflict.";
static NSString * const APCErrorJSONTasksAndScheduleIsNotAnArrayReason              = @"The JSON tasks and schedules key is returning an incorrect type";
static NSString * const APCErrorJSONTasksAndScheduleIsNotAnArraySuggestion          = @"The expected type from the JSON tasks and schedules key is an array.";
static NSString * const APCErrorJSONTasksAndSchedulesIsEmptyReason                  = @"The JSON tasks and schedules key is returning an empty array";
static NSString * const APCErrorJSONTasksAndSchedulesIsEmptySuggestion              = @"The JSON tasks and schedules may be incomplete because the array count is zero.";
static NSString * const APCErrorJSONTasksAndSchedulesNilValueForKeyReason           = @"The JSON tasks and schedules key returns nil";
static NSString * const APCErrorJSONTasksAndSchedulesNilValueForKeySuggestion       = @"The JSON tasks and schedules key returns nil. The key may be incorrect or the file is empty.";
static NSString * const APCErrorLoadingJsonFromDiskReason                           = @"Can't Open JSON File";
static NSString * const APCErrorLoadingJsonFromDiskSuggestion                       = @"We were unable to open the specified file as JSON.";
static NSString * const APCErrorLoadingJsonNoDictionaryReason                       = @"Can't Understand JSON File";
static NSString * const APCErrorLoadingJsonNoDictionarySuggestion                   = @"We were unable to find a dictionary at the top level of the JSON file at the specified path.";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectReason               = @"Can't Find Survey File";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectSuggestion           = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorLoadingSurveyFileReason                             = @"There was an error serializing the contents of a survey file";
static NSString * const APCErrorLoadingSurveyFileSuggestion                         = @"There was an error serializing the contents of a survey file. ";
static NSString * const APCErrorMoreThanOneScheduleWithSameTaskIDReason             = @"More than one schedule with this ID";
static NSString * const APCErrorMoreThanOneScheduleWithSameTaskIDSuggestion         = @"We found more than one schedule managing a task with this ID. This will give the user unexpected results.";
static NSString * const APCErrorMoreThanOneTaskWithIdAndVersionReason               = @"More than one task with this ID";
static NSString * const APCErrorMoreThanOneTaskWithIdAndVersionSuggestion           = @"We found more than one task with the specified ID, and we're not sure how to choose just one.";
static NSString * const APCErrorParsingSurveyContentReason                          = @"There was an error parsing the contents of a survey file";
static NSString * const APCErrorParsingSurveyContentSuggestion                      = @"There was an error parsing the contents of a survey file.";
static NSString * const APCErrorSavingEverythingReason                              = @"Error Saving New Schedules";
static NSString * const APCErrorSavingEverythingSuggestion                          = @"There was an error attempting to save the new schedules.";
static NSString * const APCErrorSavingToPeristentStoreReason                        = @"Error attempting to save new APCScheduledTask";
static NSString * const APCErrorSavingToPeristentStoreSuggestion                    = @"Error attempting to save new APCScheduledTask. This may give the user unexpected results.";
static NSString * const APCErrorSearchingForTaskWithIDReason                        = @"Couldn't fetch APCTask with ID";
static NSString * const APCErrorSearchingForTasksWithIDSuggestion                   = @"There was an error executing a fetch request for APCTasks with ID.";
static NSString * const APCErrorServerDisabledReason                                = @"Server disabled";
static NSString * const APCErrorServerDisabledSuggestion                            = @"The server is disabled.";
static NSString * const APCErrorTooManyTasksWithSameIDReason                        = @"More than one task with this ID";
static NSString * const APCErrorTooManyTasksWithSameIDSuggestion                    = @"We found more than one task with this ID. This will give the user unexpected results.";


/**
 Keys in the user-info dictionary for our custom NSErrors.
 */
static NSString * const kAPCErrorUserInfoKeyListOfDuplicatedTaskIDs                 = @"ListOfDuplicatedTaskIDs";


/**
 Keys and special values in the JSON dictionaries representing
 tasks and schedules.  Please alphabetize.
 */
static NSString * const kScheduleDelayKey                      = @"delay";
static NSString * const kScheduleEndDateKey                    = @"endOn";
static NSString * const kScheduleExpiresKey                    = @"expires";
static NSString * const kScheduleIDValueLocallyGeneratedPrefix = @"autogenerated";
static NSString * const kScheduleIntervalKey                   = @"interval";
static NSString * const kScheduleListOfTasksKey                = @"tasks";
static NSString * const kScheduleMaxCountKey                   = @"maxCount";
static NSString * const kScheduleNotesKey                      = @"notes";
static NSString * const kScheduleReminderMessageKey            = @"reminderMessage";
static NSString * const kScheduleReminderOffsetKey             = @"reminderOffset";
static NSString * const kScheduleShouldRemindKey               = @"shouldRemind";
static NSString * const kScheduleStartDateKey                  = @"startOn";
static NSString * const kScheduleStringKey                     = @"scheduleString";
static NSString * const kScheduleTimesOfDayKey                 = @"times";
static NSString * const kScheduleTypeKey                       = @"scheduleType";
static NSString * const kScheduleTypeValueOnce                 = @"once";
static NSString * const kTaskClassNameKey                      = @"taskClassName";
static NSString * const kTaskCompletionTimeStringKey           = @"taskCompletionTimeString";
static NSString * const kTaskFileNameKey                       = @"taskFileName";
static NSString * const kTaskIDKey                             = @"taskID";
static NSString * const kTaskIsOptionalKey                     = @"optional";
static NSString * const kTaskSortStringKey                     = @"sortString";
static NSString * const kTaskTitleKey                          = @"taskTitle";
static NSString * const kTaskTypeKey                           = @"taskType";
static NSString * const kTaskTypeValueSurvey                   = @"survey";
static NSString * const kTaskUrlKey                            = @"taskUrl";
static NSString * const kTaskVersionNumberKey                  = @"version";


/**
 The name of the queue where this class does all (or most) of its work --
 at least, its version-2 work, where we're consolidating all task-and-schedule
 math into this file from around the application suite.
 */
static NSString * const kQueueName = @"APCScheduler CoreData query queue";


@interface APCScheduler()
@property (nonatomic, weak)   APCDataSubstrate        *dataSubstrate;
@property (nonatomic, strong) NSManagedObjectContext  *scheduleMOC;
@property (nonatomic, strong) NSOperationQueue        *queryQueue;
@property (nonatomic, assign) BOOL                    isUpdating;
@property (nonatomic, strong) NSDateFormatter         *dateFormatter;
@property (nonatomic, strong) NSMutableArray          *taskGroupCache;
@property (nonatomic, strong) NSObject                *taskGroupCacheMutex;
@property (readonly)          APCAppDelegate          *appDelegate;
@property (readonly)          NSDate                  *systemDate;        // See -systemDate, below, for documentation.
@end

@implementation APCScheduler



// =========================================================
#pragma mark - I. SETUP -
// =========================================================

+ (APCScheduler *) defaultScheduler
{
    APCAppDelegate *app = [APCAppDelegate sharedAppDelegate];
    APCScheduler *scheduler = app.scheduler;
    return scheduler;
}

- (instancetype) initWithDataSubstrate: (APCDataSubstrate *) dataSubstrate
{
    self = [super init];

    if (self)
    {
        _dataSubstrate              = dataSubstrate;
        _scheduleMOC                = _dataSubstrate.persistentContext;
        _queryQueue                 = [NSOperationQueue sequentialOperationQueueWithName: kQueueName];
        _isUpdating                 = NO;
        _dateFormatter              = [NSDateFormatter new];
        _dateFormatter.dateStyle    = NSDateFormatterMediumStyle;
        _dateFormatter.timeStyle    = NSDateFormatterMediumStyle;
        _fakeSystemDate             = nil;
        _taskGroupCache             = [NSMutableArray new];
        _taskGroupCacheMutex        = [NSObject new];
    }

    return self;
}



// =========================================================
#pragma mark - II. QUERYING -
// =========================================================



// ---------------------------------------------------------
#pragma mark - Fetching tasks for all days in a range
// ---------------------------------------------------------

- (void) fetchTaskGroupsFromDate: (NSDate *) startDate
                          toDate: (NSDate *) endDate
                      usingQueue: (NSOperationQueue *) queue
                 toReportResults: (APCSchedulerCallbackForTaskGroupQueries) callbackBlock
{
    [self fetchTaskGroupsFromDate: startDate
                           toDate: endDate
           forTasksMatchingFilter: nil
                       usingQueue: queue
                  toReportResults: callbackBlock];
}

- (void) fetchTaskGroupsFromDate: (NSDate *) startDate
                          toDate: (NSDate *) endDate
          forTasksMatchingFilter: (NSPredicate *) taskFilter
                      usingQueue: (NSOperationQueue *) queue
                 toReportResults: (APCSchedulerCallbackForTaskGroupQueries) callbackBlock
{
    [self.queryQueue addOperationWithBlock: ^{

        NSMutableDictionary *results = [NSMutableDictionary new];
        NSDate *dayAfterEndDate = endDate.dayAfter.startOfDay;
        NSDate *date = startDate.startOfDay;

        for (date = startDate.startOfDay; [date isEarlierThanDate: dayAfterEndDate]; date = [date dateByAddingDays: 1])
        {
            NSArray *taskGroups = [self taskGroupsForDayOfDate: date
                                        forTasksMatchingFilter: taskFilter];
            
            if (taskGroups.count > 0) {
                results [date] = taskGroups;
            }
        }

        if (queue != nil && callbackBlock != nil)
        {
            [queue addOperationWithBlock:^{
                callbackBlock (results, nil);
            }];
        }
    }];
}

/**
 We're having a real performance problem: we're spending
 many literal seconds in this method, at various times
 throughout the app's lifetime.  Among other things, this
 is hanging the UI, but it also spends lots of time on
 background threads.

 The catch: we're almost always querying for the same
 stuff.

 The solution: we'll cache the taskGroups for a given start
 date, end date, and predicate, and clear the cache when we
 get new schedules.

 The caching mechanism is thread-safe.
 */
- (NSArray *) taskGroupsForDayOfDate: (NSDate *) date
              forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    NSArray *taskGroupsToReport = nil;

    NSArray *cachedTaskGroups = [self cachedTaskGroupsForDayOfDate: date
                                            forTasksMatchingFilter: taskFilter];

    if (cachedTaskGroups)
    {
        taskGroupsToReport = cachedTaskGroups;
    }

    else
    {
        taskGroupsToReport = [self uncachedTaskGroupsForDayOfDate: date
                                           forTasksMatchingFilter: taskFilter];

        
        /*
         Lastly:  cache these results, because of the performance problem
         mentioned at the top of this method.
         
         Note that another thread might have come through here and
         cache this same list of stuff while we were working.  That's
         fine.  The cachcing mechanism is thread-safe, and stores the
         first set of results matching this date range and filter, so
         even if a bunch of threads try to do this simultaneously,
         only one will win, and every subsequent request will use
         that cached value.
         */
        [self cacheTaskGroups: taskGroupsToReport
                      forDate: date
                    andFilter: taskFilter];
    }
    
    return taskGroupsToReport;
}

/**
 Retrieves all tasks scheduled for the specified day,
 whether completed, not-yet-completed, missed, or any other
 status.  "The specified day" means, specifically,
 midnight to midnight on that date in the user's time zone.

 This method does not manage any threading:  it expects
 to be called from a background thread -- in particular,
 a private queue managed by self.  However, it works fine
 if called from the main thread, or any other thread.

 The query turns out to be a little tricky, because of how
 we want to think about dates.  We want schedules that are
 "active on this day."  That means we want schedules whose
 start date is earlier than midnight on the specified date,
 and whose end date is later than midnight on that date.
 
 Here's the pseudocode.  The leading "."s are to preserve
 the indentation.
 
 .   -  theSpecifiedDate = the date passed to this method.
 .   
 .   -  get schedules active between morning-midnight and
 .      evening-midnight on theSpecifiedDate.  This may be
 .      a long list, including schedules that start today,
 .      schedules that end today, and schedules with either
 .      of those values set to nil.
 .   
 .   -  for each of those schedules:
 .   
 .      -   get the times of day the schedule wants to
 .          appear on this date.
 .   
 .      -   if none (if the schedule doesn't want to appear
 .          today):
 .   
 .          -   get the times of day the schedule wants to
 .              appear on the next closest previous day for
 .              that schedule.  Example:  if the schedule
 .              says "every monday and wednesday at noon
 .              and 3pm," and today is Tuesday, we'll get
 .              "noon and 3pm" for Monday.
 .
 .          -   if we got anything:  remove dates and times
 .              that specify an expired task (its grace period
 .              has run over).  We'll keep
 .              this list of times if either (a) the
 .              schedule's expiration period is nil, or
 .              (b) if the expiration period + those dates
 .              means tasks with those dates will
 .              last through theScheduledDate.
 .
 .      -   now we have a list of times of day that tasks
 .          should happen, either on theSpecifiedDate or
 .          the next-closest previous date specified by
 .          this schedule.
 .   
 .      -   if the list is non-empty:
 .   
 .          -   for each task managed by this schedule:
 .              create a TaskGroup containing all the
 .              related objects.  Specifically:
 .   
 .              -   for each of the found time slots:
 .   
 .                  -   gather any completed items for this
 .                      time slot (should be at most one,
 .                      but we'll take 'em all just in case)
 .   
 .                  -   if no completed items for this time
 .                      slot, create a Potential item for
 .                      this slot
 .
 .              -   gather any completed gratuitious items
 .                  for the scheduled date of the times in
 .                  this list
 .
 .              -   create a sample Potential gratuitous
 .                  item for that scheduled date
 .
 .              -   package all that up into a TaskGroup,
 .                  and add it to the list of results.
 .
 .              -   but wait!  if the task has been "fully
 .                  completed," and the current system date
 .                  is later than the date on which it
 .                  reached Fully Completed status, we have
 .                  to remove the taskGroup from the list.
 .                  This real-life situation is: you keep a
 .                  reminder on your fridge until you've
 .                  remembered to do that thing; then you
 .                  take it off the fridge.  The catch is:
 .                  we're creating the ability for user to
 .                  scroll backward or forward in time and
 .                  see what sticky notes *were* or *should
 .                  be* on the fridge on a given date.
 .                  Algorithm:
 .
 .                  -   if the taskGroup's
 .                      dateFullyCompleted is set, and the
 .                      current system date is greater than
 .                      midnight on the evening of that
 .                      date, remove the taskGroup from the
 .                      list of results.
 .
 .  -   (repeat for every schedule overlapping
 .      theSpecifiedDate.)

 Here we go.
 */
- (NSArray *) uncachedTaskGroupsForDayOfDate: (NSDate *) theSpecifiedDate
                      forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    NSMutableString *printout = nil;
    APCScheduleDebugPrinter *printer = nil;

#if DEBUG
    if (kAPCShowDebugPrintouts)
    {
        printout = [NSMutableString new];
        printer = [APCScheduleDebugPrinter new];
    }
#endif

    [printout appendFormat: @"\n\n-------------- Fetching uncached task groups for %@ using filter [%@]. --------------\n",
     [printer stringFromDate: theSpecifiedDate],
     taskFilter];

    NSDate *theSpecifiedMorningAtMidnight   = theSpecifiedDate.startOfDay;
    NSDate *theSpecifiedNightAtMidnight     = theSpecifiedDate.endOfDay;
    NSMutableArray *resultingTaskGroups     = [NSMutableArray new];
    NSManagedObjectContext *context         = self.scheduleMOC;
    NSError *errorFetchingSchedules         = nil;
    NSArray *activeSchedules                = [self schedulesVisibleOnDayOfDate: theSpecifiedDate
                                                                   usingContext: context
                                                                 returningError: & errorFetchingSchedules];

    if (activeSchedules == nil)   // checking for errors, not an empty list.
    {
        [printout appendFormat: @"Whoops! Failed to load schedules. Error:\n%@\n", errorFetchingSchedules.friendlyFormattedString];
    }

    else
    {
        [printer printArrayOfSchedules: activeSchedules
                             withLabel: [NSString stringWithFormat:
                                         @"\nSchedules POTENTIALLY visible between %@ and %@",
                                         [printer stringFromDate: theSpecifiedMorningAtMidnight],
                                         [printer stringFromDate: theSpecifiedNightAtMidnight]]
                     intoMutableString: printout];

        for (APCSchedule *schedule in activeSchedules)
        {
            NSDate *dateOriginallyScheduled = nil;
            NSDate *dateOfNextItemAppearance = nil;
            NSDate *expirationDate = nil;
            NSArray *timestamps = nil;
            BOOL itemHasExpired = NO;

            [self                 analyzeSchedule: schedule
                                forAppearanceDate: theSpecifiedDate
                       returningVisibleTimesOfDay: & timestamps
                        onDateOriginallyScheduled: & dateOriginallyScheduled
                                   expirationDate: & expirationDate
                hasAlreadyExpiredByAppearanceDate: & itemHasExpired
                          nextScheduledAppearance: & dateOfNextItemAppearance
                      addingDiagnosticsToPrintout: printout
                                     usingPrinter: printer];

            /*
             While the specified schedule may be active on this
             day, it may not actually emit any date values for
             this day.
             */
            if (timestamps.count)
            {
                NSSet *filteredTasks = [self filterTasksFromSchedule: schedule
                                                      withTaskFilter: taskFilter
                                         addingDiagnosticsToPrintout: printout
                                                        usingPrinter: printer];

                for (APCTask *task in filteredTasks)
                {
                    APCTaskGroup *taskGroup = [self computeAndGenerateTaskGroupForTask: task
                                                                           andSchedule: schedule
                                                                          atTheseTimes: timestamps
                                                                  onThisAppearanceDate: theSpecifiedDate
                                                                         scheduledDate: dateOriginallyScheduled
                                                                        expirationDate: expirationDate
                                                           addingDiagnosticsToPrintout: printout
                                                                          usingPrinter: printer];

                    if (taskGroup != nil)
                    {
                        /*
                         Spelling out the criteria that tell us whether or not
                         to include a task in the "today" list (whatever day
                         "today" is):
                         */
                        BOOL          isCompleted               = taskGroup.isFullyCompleted;
                        NSDate        *dateCompleted            = taskGroup.dateFullyCompleted;
                        BOOL __unused wasCompletedInThePast     = (isCompleted && [dateCompleted isEarlierThanDate: theSpecifiedMorningAtMidnight]);
                        BOOL          wasCompletedOnThisDate    = (isCompleted && [dateCompleted isLaterThanOrEqualToDate: theSpecifiedMorningAtMidnight] && [dateCompleted isEarlierOrEqualToDate: theSpecifiedNightAtMidnight]);
                        BOOL          wasCompletedInTheFuture   = (isCompleted && [dateCompleted isLaterThanDate: theSpecifiedNightAtMidnight]);
                        BOOL          shouldShowThisTaskToday   = (! isCompleted) || wasCompletedOnThisDate || wasCompletedInTheFuture;

                        if (shouldShowThisTaskToday)
                        {
                            [resultingTaskGroups addObject: taskGroup];
                        }
                    }
                }
            }
        }
    }


    NSArray *sortedGroups = [resultingTaskGroups sortedArrayUsingSelector: @selector(compareWithTaskGroup:)];

    [printout appendString: @"\nTotal list of taskGroups found:\n"];

    if (sortedGroups.count == 0)
    {
        [printout appendString: @"- (none)\n"];
    }

    else
    {
        for (APCTaskGroup *taskGroup in sortedGroups)
        {
            [printout appendFormat: @"- %@\n", taskGroup];
        }
    }

    [printout appendFormat: @"\n-------------- Done fetching uncached task groups for %@ using filter %@. --------------\n\n",
     [printer stringFromDate: theSpecifiedDate],
     taskFilter
     ];

    APCLogDebug (@"%@", printout);


    return sortedGroups;
}

/**
 Returns the times of day that the specified schedule says a task should appear
 on the given date.  This happens in one of exactly two situations:  the
 schedule says stuff should appear on exactly that date; or the schedule says
 stuff should appear on a previous date, and those items haven't "expired" yet,
 according to the schedule's expiration rule.

 Also returns the dates on either side of that date:  the date the item was
 supposed to appear, and the next date past it, which gives us the item's
 expiration date.
 

 @details
 Logic:

 We need 2 dates from the schedule:  appearanceDate, if it's a scheduled
 date, or the date just prior to it; and the date after it.  We need the
 date-after-appearanceDate so we can figure out when the stuff on
 appearanceDate will expire.  So we'll walk through the enumerator 'til we
 find the appearanceDate, get the date after that, and keep the last 2
 dates.
 
 @param expirationDateToReturn The expiration date for the specified date
 items.  This could be:  (a) nil, if the returned date items happen to be
 the last date in the schedule, and the schedule has no expiration date;
 (b) originallyScheduledDate + expiration duration, if the schedule has
 an "expires" duration; or (c) the day before the next instance of an
 item on the specified schedule.
 */
- (void)              analyzeSchedule: (APCSchedule               *) schedule
                    forAppearanceDate: (NSDate                    *) appearanceDate
           returningVisibleTimesOfDay: (NSArray * __autoreleasing *) visibleTimesOfDayToReturn
            onDateOriginallyScheduled: (NSDate  * __autoreleasing *) origniallyScheduledDateToReturn
                       expirationDate: (NSDate  * __autoreleasing *) expirationDateToReturn
    hasAlreadyExpiredByAppearanceDate: (BOOL                      *) hasExpiredToReturn
              nextScheduledAppearance: (NSDate  * __autoreleasing *) nextScheduledAppearanceToReturn
          addingDiagnosticsToPrintout: (NSMutableString           *) printout
                         usingPrinter: (APCScheduleDebugPrinter   *) printer
{
    [printer printArrayOfSchedules: @[schedule]
                         withLabel: @"\nAnalyzing schedule"
                 intoMutableString: printout];

    NSDate          *startDate                      = schedule.effectiveStartDate;
    NSDate          *appearanceMorningMidnight      = appearanceDate.startOfDay;
    NSDate          *firstDate                      = nil;
    NSDate          *secondDate                     = nil;
    NSArray         *timesOfDayOnFirstDate          = nil;
    NSMutableArray  *timesOfDayOnSecondDate         = [NSMutableArray new];
    NSDate          *expirationDate                 = nil;
    BOOL            itemHasExpired                  = NO;
    BOOL            wentTooFar                      = NO;
    NSDate          *probablyMuchTooFar             = [appearanceDate dateByAddingISO8601Duration: @"P3Y"];
    NSString        *probablyMuchTooFarDescription  = @"3 years";

    if (startDate == nil)
    {
        startDate = [APCUtilities firstKnownFileAccessDate];

        if (startDate == nil)
        {
            startDate = [NSDate date];
        }
    }


    /*
     Enumerate the dates in the schedule.  Note that this "enumerator" doesn't
     actually "enumerate"; it computes each date, based on the schedule's rules.
     Start enumerating at a "beginning of time" value because we have no idea
     how far back in the past the previous appearance might be.  As we get each
     new date, roll the tracked calendar days forward.  Stop when we reach the
     next closest calendar date immediately after the appearanceDate (or when
     the enumerator runs out, or when we seem to be heading off into the
     distant future).
     */
    APCTopLevelScheduleEnumerator *enumerator = [schedule enumeratorFromDate: startDate.startOfDay
                                                                      toDate: [NSDate distantFuture]];

    for (NSDate *date in enumerator)
    {
        NSDate *thisDateAtMidnight = date.startOfDay;

        if (secondDate == nil || [thisDateAtMidnight isLaterThanDate: secondDate.startOfDay])
        {
            firstDate = secondDate;
            secondDate = thisDateAtMidnight;

            timesOfDayOnFirstDate = [NSArray arrayWithArray: timesOfDayOnSecondDate];
            [timesOfDayOnSecondDate removeAllObjects];
        }

        if ([thisDateAtMidnight isLaterThanDate: appearanceMorningMidnight])
        {
            break;
        }

        // Error handling.
        if ([thisDateAtMidnight isLaterThanDate: probablyMuchTooFar])
        {
            wentTooFar = YES;
            break;
        }

        [timesOfDayOnSecondDate addObject: date];
    }


    //
    // If we only got one date from the enumerator, use it.
    //
    if (firstDate == nil)
    {
        firstDate = secondDate;
        timesOfDayOnFirstDate = [NSArray arrayWithArray: timesOfDayOnSecondDate];
        secondDate = nil;
        [timesOfDayOnSecondDate removeAllObjects];
    }


    //
    // If we have a date, see if it's far enough behind the appearanceDate that
    // the items have expired.
    //
    if (firstDate != nil)
    {
        /*
         Apply schedule.expires to firstDate, and see if we get anything.
         */
        expirationDate = [schedule computeExpirationDateForScheduledDate: firstDate];

        if (expirationDate)
        {
            itemHasExpired = [appearanceDate isLaterThanDate: expirationDate];
        }

        /*
         If it hasn't expired, but we do have a next date in the schedule,
         the expiration date is defined to be the day before that next date.
         */
        else if (secondDate != nil)
        {
            expirationDate = secondDate.dayBefore.endOfDay;
        }

        else
        {
            // The items never expire.  Nothing needed here.
        }
    }


    //
    // Report results.
    //
    if (wentTooFar)
    {
        [printout appendFormat: @"    Looking for date:  %@\n", [printer stringFromDate: appearanceDate]];
        [printout appendFormat: @"    -  Couldn't find enumerated date within %@ (%@) of that date.  I'll stop enumerating this schedule.\n", probablyMuchTooFarDescription, [printer stringFromDate: probablyMuchTooFar]];
    }
    else if (firstDate == nil)
    {
        [printout appendFormat: @"    Looking for date:  %@\n", [printer stringFromDate: appearanceDate]];
        [printout appendFormat: @"    -  Couldn't find any enumerable dates for that date.\n"];
    }
    else
    {
        [printout appendFormat:     @"    Looking for date:                         %@\n", [printer stringFromDate: appearanceDate]];
        [printout appendFormat:     @"    -  Found date on or before that date:     %@\n", [printer stringFromDate: firstDate]];
        [printout appendFormat:     @"    -  Times of day on that date:             %@\n", [printer stringsFromArrayOfDates: timesOfDayOnFirstDate]];
        [printout appendFormat:     @"    -  Next appearance date after that date:  %@\n", [printer stringFromDate: secondDate]];

        if (expirationDate != nil)
        {
            [printout appendFormat: @"    -  Relative expiration date:              %@\n", [printer stringFromDate: expirationDate]];
            [printout appendFormat: @"    -  Item has expired:                      %@\n", itemHasExpired ? @"YES" : @"NO"];
        }
    }


    //
    // If expired, suppress the dates.  The job of this method is to
    // figure out the date/times the schedule emits for the specified
    // appearanceDate; if expired, there are no such dates.
    //
    if (itemHasExpired)
    {
        firstDate = nil;
        timesOfDayOnFirstDate = nil;
    }


    //
    // Done.
    //
    if (visibleTimesOfDayToReturn       != nil) { * visibleTimesOfDayToReturn       = timesOfDayOnFirstDate; }
    if (origniallyScheduledDateToReturn != nil) { * origniallyScheduledDateToReturn = firstDate;             }
    if (expirationDateToReturn          != nil) { * expirationDateToReturn          = expirationDate;        }
    if (hasExpiredToReturn              != nil) { * hasExpiredToReturn              = itemHasExpired;        }
    if (nextScheduledAppearanceToReturn != nil) { * nextScheduledAppearanceToReturn = secondDate;            }
}

- (NSSet *) filterTasksFromSchedule: (APCSchedule *) schedule
                     withTaskFilter: (NSPredicate *) taskFilter
        addingDiagnosticsToPrintout: (NSMutableString *) printout
                       usingPrinter: (APCScheduleDebugPrinter *) __unused printer
{
    NSSet *result = nil;

    if (schedule == nil)
    {
        // This call turned out to be meaningless.  Return nil.
        result = nil;
    }

    else
    {
        NSSet *unfilteredTasks = schedule.tasks;

        if (unfilteredTasks.count == 0)
        {
            // No tasks.  Return nil.
            result = nil;
        }

        else
        {
            [printout appendString: @"\n    Schedule has these tasks:\n"];

            for (APCTask *task in unfilteredTasks)
            {
                [printout appendFormat: @"    -  title: %@, optional: %@\n", task.taskTitle, task.taskIsOptional];
            }

            if (taskFilter == nil)
            {
                result = unfilteredTasks;
            }
            else
            {
                NSSet *filteredTasks = [unfilteredTasks filteredSetUsingPredicate: taskFilter];

                if (filteredTasks.count == unfilteredTasks.count)
                {
                    // Nothing happened.
                    result = unfilteredTasks;
                }
                else
                {
                    result = filteredTasks;

                    [printout appendFormat: @"\n    Filtering with filter [%@] down to this list of tasks:\n", taskFilter];

                    if (filteredTasks.count == 0)
                    {
                        [printout appendString: @"    -  (none)\n"];
                    }
                    else
                    {
                        for (APCTask *task in filteredTasks)
                        {
                            [printout appendFormat: @"    -  title: %@, optional: %@\n", task.taskTitle, task.taskIsOptional];
                        }
                    }
                }
            }
        }
    }
    
    return result;
}

- (APCTaskGroup *) computeAndGenerateTaskGroupForTask: (APCTask *) task
                                          andSchedule: (APCSchedule *) schedule
                                         atTheseTimes: (NSArray *) timestamps
                                 onThisAppearanceDate: (NSDate *) appearanceDate
                                        scheduledDate: (NSDate *) scheduledDate
                                       expirationDate: (NSDate *) expirationDate
                          addingDiagnosticsToPrintout: (NSMutableString *) printout
                                         usingPrinter: (APCScheduleDebugPrinter *) printer
{
    APCTaskGroup *taskGroup = nil;

    if (timestamps.count)
    {
        [printout appendFormat: @"\n    Analyzing task:  title: %@, optional: %@\n",
         task.taskTitle,
         task.taskIsOptional
         ];
        
        NSArray *completedTasks = [self completedOrPartlyCompletedTasksForTask: task
                                                                  asOfThisDate: appearanceDate
                                                   scheduledForOneOfTheseTimes: timestamps
                                                   addingDiagnosticsToPrintout: printout
                                                                  usingPrinter: printer];

        NSArray *remainingTasks = [self generatePotentialTasksForTask: task
                                                          andSchedule: schedule
                                             givenThesePotentialTimes: timestamps
                                               andTheseCompletedTasks: completedTasks
                                          addingDiagnosticsToPrintout: printout
                                                         usingPrinter: printer];

        NSDate *generalGratuitousTaskTimestamp = [timestamps.firstObject startOfDay];

        APCPotentialTask *sampleGratuitousPotentialTask = [[APCPotentialTask alloc] initWithTask: task
                                                                                      onSchedule: schedule
                                                                          appearingAtDateAndTime: generalGratuitousTaskTimestamp];

        NSArray *completedGratuitousTasks = [self completedGratuitousTasksForTask: task
                                                      withGratuitousTaskTimestamp: generalGratuitousTaskTimestamp
                                                      addingDiagnosticsToPrintout: printout
                                                                     usingPrinter: printer];

        if (completedTasks.count == 0) { completedTasks = nil; }
        if (remainingTasks.count == 0) { remainingTasks = nil; }
        if (completedGratuitousTasks.count == 0) { completedGratuitousTasks = nil; }

        NSUInteger totalCountOfRequiredTasks = timestamps.count;

        taskGroup = [[APCTaskGroup alloc] initWithTask: task
                                              schedule: schedule
                       requiredRemainingPotentialTasks: remainingTasks
                                requiredCompletedTasks: completedTasks
                              gratuitousCompletedTasks: completedGratuitousTasks
                                   samplePotentialTask: sampleGratuitousPotentialTask
                                    totalRequiredTasks: totalCountOfRequiredTasks
                                      forScheduledDate: scheduledDate
                                        appearanceDate: appearanceDate
                                        expirationDate: expirationDate];


        [printout appendString: @"\n        Resulting taskGroup:\n"];
        [printout appendFormat:   @"        -  %@\n", taskGroup];

        if (taskGroup.isFullyCompleted && [appearanceDate isLaterThanDate: taskGroup.dateFullyCompleted.endOfDay])
        {
            [printout appendFormat: @"\n        Group was fully completed on [%@].  Current system date is [%@], which is past that date.  Omitting this group.\n", taskGroup.dateFullyCompleted, self.systemDate];
        }
        else
        {
            // Ship it!
        }
    }

    return taskGroup;
}

- (NSArray *) completedOrPartlyCompletedTasksForTask: (APCTask *) task
                                        asOfThisDate: (NSDate *) theSpecifiedDate
                         scheduledForOneOfTheseTimes: (NSArray *) timestamps
                         addingDiagnosticsToPrintout: (NSMutableString *) printout
                                        usingPrinter: (APCScheduleDebugPrinter *) printer
{
    NSPredicate *filterForCompletedTasks = [NSPredicate predicateWithFormat: @"%K in %@ && %K <= %@",
                                            NSStringFromSelector (@selector (startOn)),
                                            timestamps,
                                            NSStringFromSelector (@selector (updatedAt)),
                                            theSpecifiedDate.endOfDay
                                            ];

    NSSet *scheduledTasks = [task.scheduledTasks filteredSetUsingPredicate: filterForCompletedTasks];

    NSArray *scheduledTasksSortedByTimeScheduled = [scheduledTasks.allObjects sortedArrayUsingComparator:
                                                    ^NSComparisonResult (APCScheduledTask *scheduledTask1,
                                                                         APCScheduledTask *scheduledTask2)
                                                    {
                                                        return [scheduledTask1.startOn compare: scheduledTask2.startOn];
                                                    }];


    [printout appendString: @"        Found these probably-completed tasks:\n"];

    if (scheduledTasksSortedByTimeScheduled.count == 0)
    {
        [printout appendString: @"        -  (none)\n"];
    }
    else
    {
        for (APCScheduledTask *completedTask in scheduledTasksSortedByTimeScheduled)
        {
            [printout appendFormat: @"        -  scheduled for: %@  completedOn: %@\n", [printer stringFromDate: completedTask.startOn], [printer stringFromDate: completedTask.updatedAt]];
        }
    }

    return scheduledTasksSortedByTimeScheduled;
}

- (NSArray *) completedGratuitousTasksForTask: (APCTask *) task
                  withGratuitousTaskTimestamp: (NSDate *) timestamp
                  addingDiagnosticsToPrintout: (NSMutableString *) printout
                                 usingPrinter: (APCScheduleDebugPrinter *) printer
{
    NSSet *gratuitousTasks = [task.scheduledTasks filteredSetUsingPredicate: [NSPredicate predicateWithFormat: @"%K == %@",
                                                                              NSStringFromSelector (@selector (startOn)),
                                                                              timestamp]];

    NSArray *sortedTasks = [gratuitousTasks.allObjects sortedArrayUsingComparator:
                            ^NSComparisonResult (APCScheduledTask *scheduledTask1,
                                                 APCScheduledTask *scheduledTask2)
                            {
                                return [scheduledTask1.updatedAt compare: scheduledTask2.updatedAt];
                            }];

    [printout appendString: @"\n        Found these gratuitous completed tasks:\n"];

    if (sortedTasks.count == 0)
    {
        [printout appendString: @"        -  (none)\n"];
    }
    else
    {
        for (APCScheduledTask *gratuitousTask in sortedTasks)
        {
            [printout appendFormat: @"        -  completedOn: %@\n", [printer stringFromDate: gratuitousTask.updatedAt]];
        }
    }

    return sortedTasks;
}

- (NSArray *) generatePotentialTasksForTask: (APCTask *) task
                                andSchedule: (APCSchedule *) schedule
                   givenThesePotentialTimes: (NSArray *) timestamps
                     andTheseCompletedTasks: (NSArray *) completedTasks
                addingDiagnosticsToPrintout: (NSMutableString *) printout
                               usingPrinter: (APCScheduleDebugPrinter *) printer
{
    NSMutableArray *result = nil;

    if (timestamps.count)
    {
        result = [NSMutableArray new];

        BOOL foundAnyPotentialTasks = NO;

        [printout appendString: @"\n        Generating these potentialTasks:\n"];

        for (NSDate *time in timestamps)
        {
            NSArray *completedTasksForThisTime = [completedTasks filteredArrayUsingPredicate: [NSPredicate predicateWithFormat: @"%K == %@",
                                                                                               NSStringFromSelector (@selector (startOn)),
                                                                                               time]];

            if (completedTasksForThisTime.count == 0)
            {
                foundAnyPotentialTasks = YES;

                APCPotentialTask *potentialTask = [[APCPotentialTask alloc] initWithTask: task
                                                                              onSchedule: schedule
                                                                  appearingAtDateAndTime: time];
                [result addObject: potentialTask];
                [printout appendFormat: @"        -  scheduled for: %@\n", [printer stringFromDate: time]];
            }
        }

        if (! foundAnyPotentialTasks)
        {
            [printout appendString: @"        -  (none)\n"];
        }
    }

    return result;
}

/**
 Returns the schedules that are, or were, in their
 "started" state on the specified date.  This is NOT the
 schedules VISIBLE on that date; rather, this is schedules
 whose "start dates" are equal to or later than this date.

 This is used when importing new schedules, in
 - processSchedulesAndTasks.

 You might note that this method looks nearly identical
 to -schedulesVisibleOnDayOfDate:.  They are indeed very
 similar.  I tried parameterizing them, to make sure we
 ran the same query and same type of query in both
 cases...  and it took nearly as much code to do that as
 it took to have two separate methods.  And the separate
 methods are much more readable, because the code does
 exactly what it says it does.  (In the parameterized
 version, the code was so abstract I found it hard to
 visually verify that the query was doing what it needed
 to do.)  So two methods it is.

 @see -schedulesVisibleOnDayOfDate:
 */
- (NSArray *) schedulesActiveOnDayOfDate: (NSDate *) dateWhenThingsShouldBeActive
                              fromSource: (APCScheduleSource) scheduleSource
                               inContext: (NSManagedObjectContext *) context
                          returningError: (NSError * __autoreleasing *) errorToReturn
{
    NSDate *          midnightThisMorning = dateWhenThingsShouldBeActive.startOfDay;
    NSDate * __unused midnightThisEvening = dateWhenThingsShouldBeActive.endOfDay;    // for debugging

    NSPredicate *filter = [NSPredicate predicateWithFormat:
                           @"%K == %@ && (%K == nil || %K <= %@) && (%K == nil || %K >= %@)",
                           NSStringFromSelector (@selector (scheduleSource)),
                           @(scheduleSource),
                           NSStringFromSelector (@selector (startsOn)),             // -[APCSchedule startsOn]
                           NSStringFromSelector (@selector (startsOn)),             // -[APCSchedule startsOn]
                           midnightThisEvening,
                           NSStringFromSelector (@selector (effectiveEndDate)),     // -[APCSchedule effectiveEndDate]
                           NSStringFromSelector (@selector (effectiveEndDate)),     // -[APCSchedule effectiveEndDate]
                           midnightThisMorning
                           ];

    NSFetchRequest *request = [APCSchedule requestWithPredicate: filter];
    NSError *errorFetchingSchedules = nil;
    NSArray *schedules = [context executeFetchRequest: request error: & errorFetchingSchedules];

    if (errorToReturn != nil)
    {
        * errorToReturn = [NSError errorWithCode: APCErrorCouldntFetchActiveSchedulesForDateCode
                                          domain: APCErrorDomainLoadingTasksAndSchedules
                                   failureReason: APCErrorCouldntFetchActiveSchedulesForDateReason
                              recoverySuggestion: APCErrorCouldntFetchActiveSchedulesForDateSuggestion
                                     nestedError: errorFetchingSchedules];
    }
    
    for (APCSchedule *schedule in schedules)
    {
        [self patchSchedule:schedule];
    }

    return schedules;
}


/**
 Returns the schedules that are, or were, actually visible
 on the user's screen on the specified date.  This is
 a subset of the schedules that were ACTIVE on that date:
 a schedule can be active-but-not-visible if it has a
 non-nil "delay" value.
 
 This is used when fetching CoreData items to show
 on the screen, during -uncachedTaskGroups.

 You might note that this method looks nearly identical
 to -schedulesActiveOnDayOfDate:.  They are indeed very
 similar.  I tried parameterizing them, to make sure we
 ran the same query and same type of query in both
 cases...  and it took nearly as much code to do that as
 it took to have two separate methods.  And the separate
 methods are much more readable, because the code does
 exactly what it says it does.  (In the parameterized 
 version, the code was so abstract I found it hard to
 visually verify that the query was doing what it needed
 to do.)  So two methods it is.

 @param scheduleSource Pass APCScheduleSourceAll for all schedules.

 @see -schedulesActiveOnDayOfDate:
 */
- (NSArray *) schedulesVisibleOnDayOfDate: (NSDate *) dateWhenThingsShouldBeVisible
                             usingContext: (NSManagedObjectContext *) context
                           returningError: (NSError * __autoreleasing *) errorToReturn
{
    NSDate *midnightThisMorning = dateWhenThingsShouldBeVisible.startOfDay;
    NSDate *midnightThisEvening = dateWhenThingsShouldBeVisible.endOfDay;

    NSPredicate *filterForThisDay = [NSPredicate predicateWithFormat:
                                     @"(%K == nil || %K <= %@) && (%K == nil || %K >= %@)",
                                     NSStringFromSelector (@selector (effectiveStartDate)),       // -[APCSchedule effectiveStartDate]
                                     NSStringFromSelector (@selector (effectiveStartDate)),       // -[APCSchedule effectiveStartDate]
                                     midnightThisEvening,
                                     NSStringFromSelector (@selector (effectiveEndDate)),         // -[APCSchedule effectiveEndDate]
                                     NSStringFromSelector (@selector (effectiveEndDate)),         // -[APCSchedule effectiveEndDate]
                                     midnightThisMorning
                                     ];

    NSFetchRequest *scheduleQuery = [APCSchedule requestWithPredicate: filterForThisDay];
    NSError *errorFetchingSchedules = nil;
    NSArray *schedules = [context executeFetchRequest: scheduleQuery
                                                error: & errorFetchingSchedules];
    
    if (errorToReturn != nil)
    {
        * errorToReturn = [NSError errorWithCode: APCErrorCouldntFetchVisibleSchedulesForDateCode
                                          domain: APCErrorDomainLoadingTasksAndSchedules
                                   failureReason: APCErrorCouldntFetchVisibleSchedulesForDateReason
                              recoverySuggestion: APCErrorCouldntFetchVisibleSchedulesForDateSuggestion
                                     nestedError: errorFetchingSchedules];
    }
    
    return schedules;
}




// =========================================================
#pragma mark - III. IMPORTING -
// =========================================================



// ---------------------------------------------------------
#pragma mark - Downloading tasks and schedules from the server
// ---------------------------------------------------------

/**
 This method and -loadTasksAndSchedulesFromDisk do
 analogous things: get a list of schedules-and-tasks from a
 source (server or disk).  Then they call a central method
 to delete old versions, add the new versions, and save
 everything to disk.

 This method (-fetch) differs from -load because it has to
 extract Sage's data into an array of data with the
 key-value pairs we need.

 Both methods put the specified work onto a (private,
 serial) operation queue, and so can return to the calling
 method immediately.

 Both methods are immediately followed by methods for
 handling errors and success specific to that download
 type.  Both "success" methods call the same internal
 method for processing schedules.
 */
- (void) fetchTasksAndSchedulesFromServerAndThenUseThisQueue: (NSOperationQueue *) queue
                                            toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    /*
     Get off whatever thread we were called on.  For this outer "if"
     statement, we'll only be here for an instant, but for consistency
     in all our data-handling, we'll do everything on the same thread.
     */
    [self.queryQueue addOperationWithBlock:^{

        if (self.isServerDisabled)
        {
            NSError *errorFetchingSchedules = [NSError errorWithCode: APCErrorServerDisabledCode
                                                              domain: APCErrorDomainLoadingTasksAndSchedules
                                                       failureReason: APCErrorServerDisabledReason
                                                  recoverySuggestion: APCErrorServerDisabledSuggestion];

            [self handleErrorFetchingTasksAndSchedulesFromServer: errorFetchingSchedules
                                             andThenUseThisQueue: queue
                                                        toDoThis: callbackBlock];
        }
        else
        {
            /*
             Bounce over to the Sage SDK's thread, call the server, and then come
             back to our thread a while later.

             TODO:  Not yet using the return variable, because the code I inherited
             didn't, and I (therefore) don't yet have a use case for keeping it.
             The use case, in principle, is to be able to cancel the "fetch,"
             such as when the app goes to the background.  This might also help
             us give appropriate user feedback, like stopping the UIActivityIndicator.

                    NSURLSessionDataTask *session = ...
             */
            [SBBComponent (SBBScheduleManager) getSchedulesWithCompletion: ^(SBBResourceList *schedulesList,
                                                                             NSError *errorFetchingSchedules)
             {
                 /*
                  Immediately get off the Sage queue and back onto ours,
                  so we know and can control what's happening and what
                  resources are being used.
                  */
                 [self.queryQueue addOperationWithBlock: ^{

                     [self handleSuccessfullyFetchedTasksAndSchedulesFromServer: schedulesList
                                   givenThisPossibleErrorFromTheDownloadProcess: errorFetchingSchedules
                                                            andThenUseThisQueue: queue
                                                                       toDoThis: callbackBlock];
                 }];
             }];
        }
    }];
}

/**
 Convert inbound Sage server data to an NSDictionary of
 keys we know how to look for.

 This lets us use the same method to process data
 downloaded from the server as we do data pulled from a
 local JSON file.
 */
- (NSDictionary *) extractJsonDataFromIncomingSageSchedule: (SBBSchedule *) sageSchedule
{
    NSNull *null                                    = [NSNull null];
    NSMutableDictionary *scheduleData               = [NSMutableDictionary new];
    NSMutableArray *activities                      = [NSMutableArray new];


//    @try {
        scheduleData [kScheduleReminderMessageKey]      = [self nullIfNil: sageSchedule.label];
        scheduleData [kScheduleTypeKey]                 = [self nullIfNil: sageSchedule.scheduleType];
        scheduleData [kScheduleStartDateKey]            = [self nullIfNil: sageSchedule.startsOn];
        scheduleData [kScheduleStringKey]               = [self nullIfNil: sageSchedule.cronTrigger];
        scheduleData [kScheduleExpiresKey]              = [self nullIfNil: sageSchedule.expires];
        scheduleData [kScheduleEndDateKey]              = [self nullIfNil: sageSchedule.endsOn];
        scheduleData [kScheduleListOfTasksKey]          = activities;

        // As a reminder to get these when Sage has a chance to add them.
        scheduleData [kScheduleIntervalKey]             = null; // [self nullIfNil: sageSchedule.interval];
        scheduleData [kScheduleTimesOfDayKey]           = null; // [self nullIfNil: sageSchedule.times];
        scheduleData [kScheduleMaxCountKey]             = null; // [self nullIfNil: sageSchedule.maxCount];


        for (SBBActivity *activity in sageSchedule.activities)
        {
            NSMutableDictionary *activityData = [NSMutableDictionary new];

            activityData [kTaskTitleKey]            = [self nullIfNil: activity.label];
            activityData [kTaskTypeKey]             = [self nullIfNil: activity.activityType];
            activityData [kTaskIDKey]               = [self nullIfNil: activity.survey.guid];
            activityData [kTaskVersionNumberKey]    = [self nullIfNil: activity.survey.version];
            activityData [kTaskUrlKey]              = [self nullIfNil: activity.ref];
            activityData [kTaskClassNameKey]        = NSStringFromClass ([APCGenericSurveyTaskViewController class]);

            // When we start getting these from Sage, we'll use them.
            // In the mean time, noting them here, because we're using
            // them from our local disk files.
            activityData [kTaskCompletionTimeStringKey] = null;
            activityData [kTaskFileNameKey]             = null;
            activityData [kTaskSortStringKey]           = null;
            
            [activities addObject: activityData];
        }
//    }
//    @catch (NSException *exception) {
//        APCLogException (exception);
//    }
//    @finally {
//
//    }

    return scheduleData;
}

/**
 By the time we get here, we're safely on our private thread
 (a private serial queue).
 */
- (void) handleErrorFetchingTasksAndSchedulesFromServer: (NSError *) errorFetchingSchedules
                                    andThenUseThisQueue: (NSOperationQueue *) queue
                                               toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    APCLogError2 (errorFetchingSchedules);

    [self performFetchAndLoadCallback: callbackBlock
                              onQueue: queue
                         sendingError: errorFetchingSchedules];
}

/**
 By the time we get here, we're safely on our private thread
 (a private serial queue).
 */
- (void) handleSuccessfullyFetchedTasksAndSchedulesFromServer: (SBBResourceList *) schedulesAndTasks
                 givenThisPossibleErrorFromTheDownloadProcess: (NSError *) errorFetchingSchedules
                                          andThenUseThisQueue: (NSOperationQueue *) queue
                                                     toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{

    if (errorFetchingSchedules)
    {
        [self handleErrorFetchingTasksAndSchedulesFromServer: errorFetchingSchedules
                                         andThenUseThisQueue: queue
                                                    toDoThis: callbackBlock];
    }
    else
    {
        NSMutableArray *jsonCopyOfSageSchdulesAndTasks = nil;

        if (! errorFetchingSchedules)
        {
            jsonCopyOfSageSchdulesAndTasks = [NSMutableArray new];
            NSArray *sageSchedules = schedulesAndTasks.items;

            for (SBBSchedule *sageSchedule in sageSchedules)
            {
                NSDictionary *sageScheduleData = [self extractJsonDataFromIncomingSageSchedule: sageSchedule];

                [jsonCopyOfSageSchdulesAndTasks addObject: sageScheduleData];
            }
        }

        /*
         Loop through the incoming items and save/udpate everything.
         Both -fetch and -load boil down to this one call.
         */
        [self processSchedulesAndTasks: jsonCopyOfSageSchdulesAndTasks
                            fromSource: APCScheduleSourceServer
                   andThenUseThisQueue: queue
                      toDoThisWhenDone: callbackBlock];
    }
}



// ---------------------------------------------------------
#pragma mark - Loading tasks and schedules from disk
// ---------------------------------------------------------

/**
 This method and -fetchSchedulesFromServer do the same thing:
 get a list of schedules-and-tasks from a source (server or disk).
 Then they call a central method to delete old versions, add the
 new versions, and save everything to disk.

 This method (-load) differs from -fetch because it has to
 extract the appropriate array from a loaded JSON file.

 Both methods put the specified work onto a (private, serial)
 dispatch queue, and so can return to the calling method immediately.

 Both methods are immediately followed by methods for handling
 errors and success specific to that download type.  Both "success"
 methods call the same internal method for processing schedules.
 */
- (void) loadTasksAndSchedulesFromDiskAndThenUseThisQueue: (NSOperationQueue *) queue
                                         toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    [self.queryQueue addOperationWithBlock: ^{

        // Was:
        // [self.appDelegate.dataSubstrate loadStaticTasksAndSchedules: jsonDictionary];

        NSArray *schedulesArray = nil;
        NSError *errorToReport = nil;
        NSError *errorLoadingTasksAndSchedulesFile = nil;
        NSDictionary *jsonDictionary = [NSDictionary dictionaryWithContentsOfJSONFileWithName: kAPCStaticJSONTasksAndSchedulesFileName
                                                                                     inBundle: nil
                                                                               returningError: & errorLoadingTasksAndSchedulesFile];
        if (! jsonDictionary)
        {
            errorToReport = [NSError errorWithCode: APCErrorLoadingJsonFromDiskCode
                                            domain: APCErrorDomainLoadingTasksAndSchedules
                                     failureReason: APCErrorLoadingJsonFromDiskReason
                                recoverySuggestion: APCErrorLoadingJsonFromDiskSuggestion
                                   relatedFilePath: kAPCStaticJSONTasksAndSchedulesFileName
                                        relatedURL: nil
                                       nestedError: errorLoadingTasksAndSchedulesFile];
        }
        else
        {
            id maybeSchedulesArray = jsonDictionary [kAPCStaticJSONTasksAndSchedulesSchedulesKey];

            /* To Test each condition use or do one of these below:
             
                1. maybeSchedulesArray = nil;
             
                2. Set the check for whether the object isKindOf: NSArray
             
                3. [maybeSchedulesArray removeAllObjects]
            */

            if (maybeSchedulesArray == nil)
            {
                errorToReport = [NSError errorWithCode: APCErrorJSONTasksAndSchedulesNilValueForKeyCode
                                                domain: APCErrorDomainLoadingTasksAndSchedules
                                         failureReason: APCErrorJSONTasksAndSchedulesNilValueForKeyReason
                                    recoverySuggestion: APCErrorJSONTasksAndSchedulesNilValueForKeySuggestion];
            }

            else if (! [maybeSchedulesArray isKindOfClass: [NSArray class]])
            {
                errorToReport = [NSError errorWithCode: APCErrorJSONTasksAndScheduleIsNotAnArrayCode
                                                domain: APCErrorDomainLoadingTasksAndSchedules
                                         failureReason: APCErrorJSONTasksAndScheduleIsNotAnArrayReason
                                    recoverySuggestion: APCErrorJSONTasksAndScheduleIsNotAnArraySuggestion];
            }

            else
            {
                schedulesArray = maybeSchedulesArray;

                if (schedulesArray.count == 0)
                {
                    // This may not be an error, but it probably is.
                    errorToReport = [NSError errorWithCode: APCErrorJSONTasksAndSchedulesIsEmptyCode
                                                    domain: APCErrorDomainLoadingTasksAndSchedules
                                             failureReason: APCErrorJSONTasksAndSchedulesIsEmptyReason
                                        recoverySuggestion: APCErrorJSONTasksAndSchedulesIsEmptySuggestion];
                }
                else
                {
                    // Whew.  Looks like we got real data.  Ready to process.
                }
            }
        }

        if (errorToReport != nil)
        {
            [self handleErrorLoadingTasksAndSchedulesFromDisk: errorToReport
                                          andThenUseThisQueue: queue
                                                     toDoThis: callbackBlock];
        }

        else
        {
            [self handleSuccessfullyLoadedTasksAndSchedulesFromDisk: schedulesArray
                                                andThenUseThisQueue: queue
                                                           toDoThis: callbackBlock];
        }
    }];
}

- (void) handleErrorLoadingTasksAndSchedulesFromDisk: (NSError *) errorLoadingFromDisk
                                 andThenUseThisQueue: (NSOperationQueue *) queue
                                            toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    APCLogError2 (errorLoadingFromDisk);


#if DEBUG

    /*
     In debug mode, if this happens, the developer/QA
     person probably made a typo in the JSON file, like
     forgetting to add a comma after copying-and-pasting.
     So, in this non-production situation, let them (us)
     know very clearly.
     */

    NSString *errorMessage = [NSString stringWithFormat:
                              @"\n\n"
                              "============ error: couldn't open JSON file =============\n"
                              "We had trouble loading the JSON file.  Maybe there's a copy-and-paste error?  Here's the original error message:\n\n"
                              "%@\n"
                              "=========================================================\n",
                              errorLoadingFromDisk.friendlyFormattedString];

    /*
     If the app crashes here, we couldn't read the JSON
     file.  See console for details.
     */
    APCLogDebug (errorMessage);
    NSAssert (NO, errorMessage);

#endif


    [self performFetchAndLoadCallback: callbackBlock
                              onQueue: queue
                         sendingError: errorLoadingFromDisk];
}

- (void) handleSuccessfullyLoadedTasksAndSchedulesFromDisk: (NSArray *) taskAndSchduleData
                                       andThenUseThisQueue: (NSOperationQueue *) queue
                                                  toDoThis: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    /*
     Loop through the incoming items and save/udpate everything.
     Both -fetch and -load boil down to this one call.
     */
    [self processSchedulesAndTasks: taskAndSchduleData
                        fromSource: APCScheduleSourceLocalDisk
               andThenUseThisQueue: queue
                  toDoThisWhenDone: callbackBlock];
}



// ---------------------------------------------------------
#pragma mark - Loading tasks and schedules from dictionaries
// ---------------------------------------------------------

- (void) importScheduleFromDictionary: (NSDictionary *) scheduleContainingTasks
                      assigningSource: (APCScheduleSource) scheduleSource
                  andThenUseThisQueue: (NSOperationQueue *) queue
                     toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    [self.queryQueue addOperationWithBlock:^{
        [self processSchedulesAndTasks: @[scheduleContainingTasks]
                            fromSource: scheduleSource
                   andThenUseThisQueue: queue
                      toDoThisWhenDone: callbackBlock];
    }];
}



// ---------------------------------------------------------
#pragma mark - The core import process
// ---------------------------------------------------------

/**
 This method is the core of our effort when loading
 schedules, where we:
 - unify the processing for schedules and tasks from Sage
    and local disk, and
 - compute the "effective start" and "effective end" dates

 Here's how the process of creating schedules and tasks
 works, and why.

 We have 2 types of schedules: downloaded and local.  As a
 business requirement, both types COMPLETELY REPLACE any
 existing schedules of that type.  To expire a schedule,
 the authors simply don't mention it in the download; and
 to expire a task, the authors simply don't make a schedule
 for it.

 The catch is: we need to see what was SUPPOSED to happen
 in the past.  So we have to track schedules that were once
 visible to the user, but no longer, and show them to the
 user under certain circumstances.  We need to show the
 users what the researchers EXPECTED them to do, while also
 making that thing undoable.  If they miss a task in the
 past, we need to dim it.

 Schedules are downloaded every time the user does a
 pull-to- refresh or launches the app.  It can happen as
 often as every few seconds, or as seldom as every few
 weeks.  Schedules are also loaded from disk every time the
 app loads.

 Tasks show up on a calendar (a view, any view) for 2
 reasons:
 -  because a schedule says the user *could* do the
    task on a certain date
 -  because the task was actually done on a certain date

 Example: A researcher schedules a "please enter your
 weight" task for every Monday.  On Tuesday, March 5, the
 researcher changes that schedule to be "every Tuesday and
 Thursday": she wants the user to measure his weight every
 Tuesday and Thursday.  The user didn't do the task
 yesterday, Monday, March 5.  So if the user looks at
 YESTERDAY's calendar: what does he see?  Nothing, because
 the new schedule for that task says "Tuesday and
 Thursday"?  Or one missed task, because the schedule AT
 THAT TIME said "every Monday"?  The answer: we show the
 user whatever was true FOR HIM, yesterday.  Downloading a
 schedule shouldn't "rewrite the past." It should simply
 tell the user what can happen from this day *forward*.

 There are 2 parts to getting this to happen:
 -  Downloading tasks and schedules, and then adding,
    updating, or deleting them in the system.
 -  Showing tasks appropriately when the user looks
    at a calendar.

 We'll keep those two issues utterly separate.  This class
 does the first one: download and update.  Here's how it
 works:

 1. The user downloads (from the server) or loads (from
    disk) some schedules and tasks, either by launching
    the app or by pull-to-refresh.  We look at the existing
    schedules, and:

 a. We delete any schedules with "effective" start dates
    of today or later.

 b. If any schedules have effective start AND end dates
    before midnight tonight, we leave them alone.

 c. If any schedules have effective START dates before
    midnight tonight, but an END date of today or later,
    we give them an end date of this morning at midnight.


 Then we add our new schedules into the system.

 Note: the "effective start date" and "effective end date"
 of a schedule are the dates and times the schedule
 *actually* begins and ends, after accounting for its start
 delay and expiration period.


 2. Each loaded Schedule includes one or more tasks.  For
    each schedule, look at each contained task, and:

 a. If the schedule links to a task whose ID/version
    aren't already here: Simply create the new task.

 b. If a schedule links to a task whose ID and version IS
    already here: see if the *contents* of that task have
    changed.  If no change, link to the existing task.  If
    changed, create a new task with a different locally-
    created ID and version.


 3. A really common "edge case": the user does
    pull-to-refresh five times between 9am and 10am the same
    day -- say, a minute apart.  At the same time, out in
    the real world, our friendly researcher is busily
    playing with tasks and schedules.  So each time the
    user gets a download, he gets not only new schedules,
    but new tasks.  In this case: when we're about to
    delete the schedules that were downloaded earlier today
    (case 1a, above), we see if the tasks owned by those
    schedules are owned by any other schedules.  If not --
    if the only schedules owning those tasks are the
    schedules we're about to delete -- delete those tasks,
    too.
 */
- (void) processSchedulesAndTasks: (NSArray *) arrayOfSchedulesAndTasks
                       fromSource: (APCScheduleSource) scheduleSource
              andThenUseThisQueue: (NSOperationQueue *) queue
                 toDoThisWhenDone: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
{
    // The original code did this.  Not yet sure it's necessary.
    // APCLogEventWithData (kAnalyticsNetworkEvent, @{@"event_detail":  @"schedule updated"});

    NSMutableString *printout = nil;
    APCScheduleDebugPrinter *printer = nil;

    #if DEBUG
        if (kAPCShowDebugPrintouts)
        {
            printout = [NSMutableString new];
            printer = [APCScheduleDebugPrinter new];
        }
    #endif

    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    context.parentContext = self.scheduleMOC;
    
    __block NSError *finalErrorFromThisMethod = nil;
    
    [context performBlockAndWait:^{
        
        NSDate *timeBeforeStarting = self.systemDate;
        NSDate *today = timeBeforeStarting;
        
        
        /*
         The import-and-merge algorithm, v4:
         -  compare all incoming schedules to all active schedules, including comparing their tasks
         -  for each one found:  update its tasks with new data, if needed
         -  for each one NOT found:  create it, and create or update its tasks
         -  for each active schedule therefore NOT found:  disable it
         */
        NSError *errorFetchingCurrentSchedules = nil;
        NSArray *currentSchedules = [self schedulesActiveOnDayOfDate: today
                                                          fromSource: scheduleSource
                                                           inContext: context
                                                      returningError: & errorFetchingCurrentSchedules];
        
        if (! currentSchedules)
        {
            finalErrorFromThisMethod = errorFetchingCurrentSchedules;
        }
        
        else
        {
            NSArray *rawIncomingSchedules = [self createSchedulesAndUpdateTasksFromIncomingData: arrayOfSchedulesAndTasks
                                                                                      forSource: scheduleSource
                                                                                      inContext: context];
            NSArray *uniquifiedIncomingSchedules = nil;
            NSArray *schedulesWithDuplicateTaskIDs = nil;
            NSArray *duplicateTaskIds = nil;
            
            [self findDuplicateTaskIdsInIncomingSchedules: rawIncomingSchedules
                          returningTheUniquifiedSchedules: & uniquifiedIncomingSchedules
                                     theDuplicatedTaskIDs: & duplicateTaskIds
                              andTheSchedulesWeWillIgnore: & schedulesWithDuplicateTaskIDs];
            
            if (duplicateTaskIds.count)
            {
                /*
                 If the app crashes inside this method call, it
                 means your JSON file contains one or more
                 schedules with the same task ID.  See the
                 console for which task IDs are duplicated.
                 */
                [self reportLoudlyAboutDuplicateTaskIds: duplicateTaskIds
                          andTheSchedulesContainingThem: schedulesWithDuplicateTaskIDs
                                             fromSource: scheduleSource];
            }
            
            
            /*
             Filter out schedules whose tasks are already completed
             and should never be run again (the one-time tasks).
             */
            NSArray *incomingSchedulesWithoutCompletedOneTimeTasks = nil;
            NSArray *incomingSchedulesWithCompletedOneTimeTasks = [self selectSchedulesWithCompletedOneTimeTasks: uniquifiedIncomingSchedules
                                                                                                       inContext: context
                                                                  returningSchedulesWithoutCompletedOneTimeTasks: & incomingSchedulesWithoutCompletedOneTimeTasks];
            
            
            /*
             Take various unions and intersections of the
             current schedules and the incoming schedules.
             This is the CORE OF THE BUSINESS LOGIC in this
             method.
             */
            NSArray *incomingSchedulesToAnalyze = incomingSchedulesWithoutCompletedOneTimeTasks;
            
            NSArray *schedulesThatAreAlreadyPerfect = [self arrayByFindingCommonElementsInScheduleArray: currentSchedules
                                                                                       andScheduleArray: incomingSchedulesToAnalyze
                                                                            comparingObjectsUsingFields: YES];
            
            NSArray *oldSchedulesToKillOrDelete = [self arrayByRemovingElementsInScheduleArray: incomingSchedulesToAnalyze
                                                                             fromScheduleArray: currentSchedules
                                                                   comparingObjectsUsingFields: YES];
            
//            NSArray *schedulesFromThisMorningToDelete = [oldSchedulesToKillOrDelete filteredArrayUsingPredicate: [NSPredicate predicateWithFormat: @"%K >= %@ && %K <= %@",
//                                                                                                                  NSStringFromSelector (@selector (createdAt)),
//                                                                                                                  morningMidnight,
//                                                                                                                  NSStringFromSelector (@selector (createdAt)),
//                                                                                                                  eveningMidnight]];
//            
//            NSArray *oldSchedulesToTerminate = [self arrayByRemovingElementsInScheduleArray: schedulesFromThisMorningToDelete
//                                                                          fromScheduleArray: oldSchedulesToKillOrDelete
//                                                                comparingObjectsUsingFields: NO];
            NSArray *oldSchedulesToTerminate = oldSchedulesToKillOrDelete;
            
            NSArray *newSchedulesToKeep = [self arrayByRemovingElementsInScheduleArray: schedulesThatAreAlreadyPerfect
                                                                     fromScheduleArray: incomingSchedulesToAnalyze
                                                           comparingObjectsUsingFields: YES];
            
            NSArray *unnecessaryImportedSchedulesToDelete = [self arrayByRemovingElementsInScheduleArray: newSchedulesToKeep
                                                                                       fromScheduleArray: incomingSchedulesToAnalyze
                                                                             comparingObjectsUsingFields: NO];
            
            
            //
            // Print the analysis so far, before we change some of these
            // schedule objects.
            //
            
            [printout appendFormat:
             @"\n\n======================= new batch of schedules from %@ =======================\n",
             NSStringFromAPCScheduleSource (scheduleSource)];
            
            [printer printArrayOfSchedules: currentSchedules                          withLabel: @"Current Schedules"                                                intoMutableString: printout];
            [printer printArrayOfSchedules: uniquifiedIncomingSchedules               withLabel: @"Incoming Schedules with unique task IDs (we'll analyze these)"    intoMutableString: printout];
            [printer printArrayOfSchedules: schedulesWithDuplicateTaskIDs             withLabel: @"Incoming Schedules with duplicate task IDs (we'll delete these)"  intoMutableString: printout];
            [printer printArrayOfSchedules: incomingSchedulesWithCompletedOneTimeTasks  withLabel: @"Incoming Schedules with completed one-time tasks (we'll delete these, and turn off the ones they replace)" intoMutableString: printout];
            [printer printArrayOfSchedules: schedulesThatAreAlreadyPerfect            withLabel: @"Current Schedules that are Already Perfect"                       intoMutableString: printout];
            [printer printArrayOfSchedules: newSchedulesToKeep                        withLabel: @"Incoming Schedules to Keep"                                       intoMutableString: printout];
//            [printer printArrayOfSchedules: schedulesFromThisMorningToDelete          withLabel: @"Schedules imported earlier today to delete"                       intoMutableString: printout];
            [printer printArrayOfSchedules: oldSchedulesToTerminate                   withLabel: @"Current Schedules to Terminate"                                   intoMutableString: printout];
            [printer printArrayOfSchedules: unnecessaryImportedSchedulesToDelete      withLabel: @"Unneded Incoming Schedules to Delete"                             intoMutableString: printout];
            
            
            //
            // ok, back to business logic
            //
            
            [self disableSchedules: oldSchedulesToTerminate];
            
//            [self deleteSchedulesButNotTasks: schedulesFromThisMorningToDelete
//                                   inContext: context];
            
            [self deleteSchedulesButNotTasks: unnecessaryImportedSchedulesToDelete
                                   inContext: context];
            
            [self deleteSchedulesButNotTasks: schedulesWithDuplicateTaskIDs
                                   inContext: context];
            
            [self deleteSchedulesButNotTasks: incomingSchedulesWithCompletedOneTimeTasks
                                   inContext: context];
            
            
            //
            // All that being said, there may still be nothing to save.
            //
            
            if (! context.hasChanges)
            {
                [printout appendString: @"\n...which means, all told, there's nothing to save.  We're done.\n\n"];
            }
            else
            {
                NSManagedObject *anySaveableObject = uniquifiedIncomingSchedules.firstObject;
                NSError *errorSavingEverything = nil;
                BOOL saved = [anySaveableObject saveToPersistentStore: & errorSavingEverything];
                
                if (! saved)
                {
                    finalErrorFromThisMethod = [NSError errorWithCode: APCErrorSavingEverythingCode
                                                               domain: APCErrorDomainLoadingTasksAndSchedules
                                                        failureReason: APCErrorSavingEverythingReason
                                                   recoverySuggestion: APCErrorSavingEverythingSuggestion
                                                          nestedError: errorSavingEverything];
                }
            }
            
            
            //
            // Ok, what happened?
            //
            
            NSArray *currentSchedulesAfterImport = [self schedulesActiveOnDayOfDate: today
                                                                         fromSource: scheduleSource
                                                                          inContext: context
                                                                     returningError: & errorFetchingCurrentSchedules];
            
            [printout appendString: @"--------\nResults\n--------\n"];
            
            [printer printArrayOfSchedules: currentSchedulesAfterImport  withLabel: @"Current schedules after import" intoMutableString: printout];
            
            [printer printArrayOfSchedules: oldSchedulesToTerminate  withLabel: @"Terminated schedules" intoMutableString: printout];
            
            
            //
            // And, finally, print it.
            //
            
            NSDate *timeAtEnd = self.systemDate;
            NSTimeInterval totalTime = [timeAtEnd timeIntervalSinceDate: timeBeforeStarting];
            [printout appendFormat: @"\nTotal time: %f seconds\n", totalTime];
            
            [printout appendFormat:
             @"======================= end batch of schedules from %@ =======================\n\n",
             NSStringFromAPCScheduleSource (scheduleSource)];
            
            NSLog (@"%@", printout);
        }
        
        if (finalErrorFromThisMethod)
        {
            APCLogError2 (finalErrorFromThisMethod);
        }
        
        
        /*
         Lastly:  clear the performance cache.
         */
        [self clearTaskGroupCache];
        
    }];
    
    [self performFetchAndLoadCallback: callbackBlock
                              onQueue: queue
                         sendingError: finalErrorFromThisMethod];
}

- (NSArray *) createSchedulesAndUpdateTasksFromIncomingData: (NSArray *) incomingSchedulesAndTasks
                                                  forSource: (APCScheduleSource) scheduleSource
                                                  inContext: (NSManagedObjectContext *) context
{
    NSMutableArray *schedules = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingSchedulesAndTasks)
    {
        APCSchedule *schedule = [self createOneScheduleAndItsTasksFromJsonData: scheduleData
                                                                    fromSource: scheduleSource
                                                                  usingContext: context];

        [schedules addObject: schedule];
    }

    return schedules;
}

- (void) findDuplicateTaskIdsInIncomingSchedules: (NSArray *) incomingSchedulesAndTasks
                 returningTheUniquifiedSchedules: (NSArray * __autoreleasing * ) uniquifiedSchedulesToReturn
                            theDuplicatedTaskIDs: (NSArray * __autoreleasing * ) duplicateTaskIdsToReturn
                     andTheSchedulesWeWillIgnore: (NSArray * __autoreleasing * ) duplicateSchedulesToReturn
{
    NSMutableArray *uniqueTaskIds       = [NSMutableArray new];
    NSMutableArray *duplicateTaskIds    = [NSMutableArray new];
    NSMutableArray *uniquifiedSchedules = [NSMutableArray new];
    NSMutableArray *duplicateSchedules  = [NSMutableArray new];

    for (APCSchedule *schedule in incomingSchedulesAndTasks)
    {
        BOOL thisScheduleContainsSomeoneElsesTaskId = NO;

        for (APCTask *task in schedule.tasks)
        {
            NSString *taskId = task.taskID;

            if (taskId == nil)
            {
                taskId = kAPCNullTaskIdString;
            }

            if ([uniqueTaskIds containsObject: taskId])
            {
                thisScheduleContainsSomeoneElsesTaskId = YES;
                [duplicateTaskIds addObject: taskId];
                break;
            }
            else
            {
                [uniqueTaskIds addObject: taskId];
            }
        }

        if (thisScheduleContainsSomeoneElsesTaskId)
        {
            [duplicateSchedules addObject: schedule];
        }
        else
        {
            [uniquifiedSchedules addObject: schedule];
        }
    }

    /*
     These results are intended to be human-readable,
     so sort them.  The task IDs are strings, so we can
     sort by their -compare: method.  We'll sort the
     schedules by a comparator we use to sort all lists of
     schedules when we print them.
     */
    [duplicateTaskIds    sortUsingSelector: @selector (compare:)];
    [uniquifiedSchedules sortUsingSelector: @selector (compareWithSchedule:)];
    [duplicateSchedules  sortUsingSelector: @selector (compareWithSchedule:)];

    // Ship 'em.
    if (uniquifiedSchedulesToReturn != nil) { * uniquifiedSchedulesToReturn = uniquifiedSchedules; }
    if (duplicateTaskIdsToReturn    != nil) { * duplicateTaskIdsToReturn    = duplicateTaskIds;    }
    if (duplicateSchedulesToReturn  != nil) { * duplicateSchedulesToReturn  = duplicateSchedules;  }
}

- (void) reportLoudlyAboutDuplicateTaskIds: (NSArray *) duplicateTaskIds
             andTheSchedulesContainingThem: (NSArray *) schedulesContainingThoseIDs
                                fromSource: (APCScheduleSource) scheduleSource
{
    if (duplicateTaskIds.count)
    {
        NSString *errorMessage = nil;

        if (scheduleSource == APCScheduleSourceServer)
        {
            errorMessage = APCErrorMoreThanOneScheduleWithSameTaskIDSuggestion;
        }
        else
        {
            APCScheduleDebugPrinter *printer = [APCScheduleDebugPrinter new];

            NSMutableString *message = [NSMutableString stringWithFormat:
                                        @"\n\n============ error: duplicate task IDs =============\nMore than one schedule in the imported JSON data is referring to the same task ID.  (Copy-and-paste error?)\n\nHere are the duplicate task IDs:\n"];

            for (NSString *taskId in duplicateTaskIds)
            {
                [message appendFormat: @"-  %@\n", taskId];
            }

            [printer printArrayOfSchedules: schedulesContainingThoseIDs
                                 withLabel: @"\nHere are the schedules containing those IDs"
                         intoMutableString: message];

            [message appendString: @"====================================================\n"];

            errorMessage = message;
        }

        NSError *errorForDuplicateTaskIds = [NSError errorWithCode: APCErrorMoreThanOneScheduleWithSameTaskIDCode
                                                            domain: APCErrorDomainLoadingTasksAndSchedules
                                                     failureReason: APCErrorMoreThanOneScheduleWithSameTaskIDReason
                                                recoverySuggestion: errorMessage
                                                   relatedFilePath: nil
                                                        relatedURL: nil
                                                       nestedError: nil
                                                     otherUserInfo: @{ kAPCErrorUserInfoKeyListOfDuplicatedTaskIDs : duplicateTaskIds }];

        APCLogError2 (errorForDuplicateTaskIds);

#if DEBUG
        // If the app crashes here, you have duplicate
        // task IDs in your JSON file.  See console for
        // details.
        NSAssert (NO, errorMessage);
#endif

    }
}

- (BOOL) updateTasksInSchedules: (NSArray *) schedulesThatAreAlreadyPerfect
               fromIncomingData: (NSArray *) incomingScheduleAndTaskData
{
    BOOL result = NO;

    for (APCSchedule *schedule in schedulesThatAreAlreadyPerfect)
    {
        for (APCTask *task in schedule.tasks)
        {
            NSString *taskId = task.taskID;
            NSNumber *taskVersion = task.taskVersionNumber;
            NSDictionary *taskData = [self extractTaskDataFromIncomingListOfSchedulesAndTasks: incomingScheduleAndTaskData
                                                                               withThisTaskId: taskId
                                                                               andThisVersion: taskVersion];
            [self updateTask: task
                    withData: taskData];
        }
    }

    return result;
}

/**
 Crawls through the dictionaries and arrays in the incoming
 data until it finds a task dictionary containing the
 specified id and version.

 Currently unexpected edge case: if more than one schedule
 specifies a task with the same ID and version.  Our world
 is truly undefined if that happens; as a business rule,
 it's not supposed to.  So this method currently ignores
 that situation -- it returns the first task data matching
 the specified task and ID.
 */
- (NSDictionary *) extractTaskDataFromIncomingListOfSchedulesAndTasks: (NSArray *) incomingScheduleAndTaskData
                                                       withThisTaskId: (NSString *) taskId
                                                       andThisVersion: (NSNumber *) taskVersion
{
    NSDictionary *foundTaskData = nil;
    NSMutableArray *taskDataWithSameIdAndVersion = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingScheduleAndTaskData)
    {
        NSArray *tasksForThisSchedule = scheduleData [kScheduleListOfTasksKey];

        for (NSDictionary *taskData in tasksForThisSchedule)
        {
            NSString *taskIdFromData      = [self nilIfNull: taskData [kTaskIDKey]];
            NSNumber *taskVersionFromData = [self nilIfNull: taskData [kTaskVersionNumberKey]];

            if ([self object1: taskId      equalsObject2: taskIdFromData]      &&
                [self object1: taskVersion equalsObject2: taskVersionFromData] )
            {
                [taskDataWithSameIdAndVersion addObject: taskData];
            }
        }
    }

    if (taskDataWithSameIdAndVersion.count == 0)
    {
        // Truly should never happen, since we got the taskID
        // and version from a previous pass through the data.
    }

    else if (taskDataWithSameIdAndVersion.count == 1)
    {
        // This is what we were expecting.
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }

    else    // .count > 1
    {
        NSError *tooManyTasksWithSameIdAndVersion = [NSError errorWithCode: APCErrorInboundListOfSchedulesAndTasksIssuesCode
                                                                    domain: APCErrorDomainLoadingTasksAndSchedules
                                                             failureReason: APCErrorInboundListOfSchedulesAndTasksIssuesReason
                                                        recoverySuggestion: APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion
                                                           relatedFilePath: nil
                                                                relatedURL: nil
                                                               nestedError: nil
                                                             otherUserInfo: @{ kTaskIDKey            : [self nullIfNil: taskId],
                                                                               kTaskVersionNumberKey : [self nullIfNil: taskVersion] }];
        APCLogError2 (tooManyTasksWithSameIdAndVersion);

        // Therefore, this is kinda undefined:
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }

    return foundTaskData;
}

- (NSSet *) extractTaskIdsFromSchedules: (NSArray *) schedules
{
    NSMutableSet *taskIds = [NSMutableSet new];

    for (APCSchedule *schedule in schedules)
    {
        [taskIds unionSet: schedule.taskIds];
    }

    return [NSSet setWithSet: taskIds];
}

/**
 Filter out schedules whose tasks are already completed
 and should never be run again (the one-time tasks).
 */
- (NSArray *) selectSchedulesWithCompletedOneTimeTasks: (NSArray *) schedules
                                             inContext: (NSManagedObjectContext *) context
        returningSchedulesWithoutCompletedOneTimeTasks: (NSArray * __autoreleasing *) schedulesWithoutCompletedOneTimeTasksToReturn
{
    NSMutableArray *schedulesWithCompletedOneTimeTasks    = [NSMutableArray new];
    NSMutableArray *schedulesWithoutCompletedOneTimeTasks = [NSMutableArray new];

    NSSet *incomingTaskIds = [self extractTaskIdsFromSchedules: schedules];

    NSSet *completedOneTimeTaskIds = [self queryForCompletedOneTimeTaskIds: incomingTaskIds
                                                                 inContext: context];

    for (APCSchedule *schedule in schedules)
    {
        if ([schedule.taskIds intersectsSet: completedOneTimeTaskIds])
        {
            [schedulesWithCompletedOneTimeTasks addObject: schedule];
        }
        else
        {
            [schedulesWithoutCompletedOneTimeTasks addObject: schedule];
        }
    }

    if (schedulesWithoutCompletedOneTimeTasksToReturn != nil)
    {
        * schedulesWithoutCompletedOneTimeTasksToReturn = schedulesWithoutCompletedOneTimeTasks;
    }

    return schedulesWithCompletedOneTimeTasks;
}

- (NSSet *) queryForCompletedOneTimeTaskIds: (NSSet *) taskIds
                                  inContext: (NSManagedObjectContext *) context
{
    NSMutableSet *result = [NSMutableSet new];
    NSString *selectorForTaskIdField    = NSStringFromSelector (@selector (taskID));    // meaning: -[APCTask taskID]
    NSString *selectorForStartDateField = NSStringFromSelector (@selector (startsOn));  // meaning: -[APCSchedule startsOn]

    NSArray *sortByStartDate = @[[NSSortDescriptor sortDescriptorWithKey: selectorForStartDateField
                                                               ascending: NO]];

    NSFetchRequest *request = [APCTask requestWithPredicate: [NSPredicate predicateWithFormat: @"%K in %@",
                                                              selectorForTaskIdField,
                                                              taskIds]];

    NSError *errorDuringQuery = nil;
    NSArray *tasks = [context executeFetchRequest: request error: & errorDuringQuery];

    if (tasks == nil)
    {
        // For ease of debugging. In practice, this shouldn't
        // happen:  we'd never have gotten here if we couldn't
        // do a query.
    }
    else
    {
        for (APCTask *task in tasks)
        {
            BOOL isOneTimeTaskThatIsAlsoCompleted = NO;
            NSString *taskId = task.taskID;

            if (task.objectID.isTemporaryID == NO &&    // filter out tasks we're just creating, and haven't saved yet.
                taskId.length > 0)
            {
                // Only look at schedules which existed before this
                // import process began.
                NSSet *existingSchedules = [task.schedules objectsPassingTest: ^BOOL (APCSchedule   *schedule,
                                                                                      BOOL __unused *stopLooking)
                                            {
                                                BOOL keepThisOne = schedule.objectID.isTemporaryID == NO;
                                                return keepThisOne;
                                            }];


                if (existingSchedules.count == 0)
                {
                    /*
                     Skip this task; it doesn't have a schedule. That's
                     probably very bad, but not our problem in this method.
                     */
                }
                else
                {
                    /*
                     This task is a "one-time task" if its most recent schedule
                     was a one-time schedule.  Schedules' start dates should be in
                     strictly-increasing order, as a result of the import process,
                     so we can sort by those.
                     */
                    NSArray *sortedSchedules = [existingSchedules sortedArrayUsingDescriptors: sortByStartDate];
                    APCSchedule *mostRecentControllingSchedule = sortedSchedules.firstObject;
                    BOOL isOneTimeTask = mostRecentControllingSchedule.isOneTimeSchedule;

                    if (isOneTimeTask)
                    {
                        for (APCScheduledTask *maybeCompletedTask in task.scheduledTasks)
                        {
                            if (maybeCompletedTask.generatedSchedule == mostRecentControllingSchedule &&
                                maybeCompletedTask.completed.boolValue)
                            {
                                isOneTimeTaskThatIsAlsoCompleted = YES;
                                break;
                            }
                        }
                    }
                }
            }

            if (isOneTimeTaskThatIsAlsoCompleted)
            {
                [result addObject: taskId];
            }
        }
    }

    return result;
}


/**
 For future consideration: consider whether we'll ever need
 to UNDO this operation.  If so, we may want to add two
 properties to the Schedule: something like
 forcedTerminationDate and scheduleForcingTermination.  And
 change all our queries based on "effectiveEndDate" to use
 that in addition or instead.  Then, if we wanted to roll
 back, we could simply nil out those two fields, and the
 schedule would pop back into existence.
 */
- (void) disableSchedules: (NSArray *) schedulesToTerminate
{
    NSDate *endOfDayYesterday = self.systemDate.dayBefore.endOfDay;   // 23:59:59

    for (APCSchedule *schedule in schedulesToTerminate)
    {
        schedule.effectiveEndDate = endOfDayYesterday;
    }
}

- (void) deleteSchedulesButNotTasks: (NSArray *) schedulesToDelete
                          inContext: (NSManagedObjectContext *) context
{
    for (APCSchedule *schedule in schedulesToDelete)
    {
        [context deleteObject: schedule];
    }
}

- (APCSchedule *) createOneScheduleAndItsTasksFromJsonData: (NSDictionary *) inboundScheduleData
                                                fromSource: (APCScheduleSource) scheduleSource
                                              usingContext: (NSManagedObjectContext *) context
{
    APCSchedule *schedule   = [APCSchedule newObjectForContext: context];
    schedule.scheduleSource = @(scheduleSource);

    NSMutableDictionary *scheduleData = inboundScheduleData.mutableCopy;


    //
    // Pre-import data validation.
    //

    id requestedStartDate = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    id requestedEndDate   = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    id timesOfDay         = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey] ];

    if ([requestedStartDate isKindOfClass: [NSString class]])
    {
        requestedStartDate = [NSDate dateWithISO8601String: requestedStartDate];
    }

    if ([requestedEndDate isKindOfClass: [NSString class]])
    {
        requestedEndDate = [NSDate dateWithISO8601String: requestedEndDate];
    }

    if ([timesOfDay isKindOfClass: [NSArray class]])
    {
        timesOfDay = [self serializedTimesOfDayStringFromISO8601TimesOfDayInArray: timesOfDay];
    }

    scheduleData [kScheduleStartDateKey]  = [self nullIfNil: requestedStartDate];
    scheduleData [kScheduleEndDateKey]    = [self nullIfNil: requestedEndDate];
    scheduleData [kScheduleTimesOfDayKey] = [self nullIfNil: timesOfDay];



    //
    // Copy the data into our local object.  Please alphabetize.
    //

    schedule.delay                  = [self nilIfNull: scheduleData [kScheduleDelayKey]];
    schedule.endsOn                 = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    schedule.expires                = [self nilIfNull: scheduleData [kScheduleExpiresKey]];
    schedule.interval               = [self nilIfNull: scheduleData [kScheduleIntervalKey]];
    schedule.maxCount               = [self nilIfNull: scheduleData [kScheduleMaxCountKey]];
    schedule.notes                  = [self nilIfNull: scheduleData [kScheduleNotesKey]];
    schedule.reminderMessage        = [self nilIfNull: scheduleData [kScheduleReminderMessageKey]];         // if from Sage:  "label"
    schedule.reminderOffset         = [self nilIfNull: scheduleData [kScheduleReminderOffsetKey]];
    schedule.scheduleString         = [self nilIfNull: scheduleData [kScheduleStringKey]];
    schedule.scheduleType           = [self nilIfNull: scheduleData [kScheduleTypeKey]];
    schedule.shouldRemind           = [self nilIfNull: scheduleData [kScheduleShouldRemindKey]];
    schedule.startsOn               = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    schedule.timesOfDay             = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey]];
    
    //
    // Add data validation, defaults, and calculations.
    //

    /*
     Start date:  this morning, at midnight, whenever "this
     morning" is.  NOT the app-installation time; that might
     be months ago, which would not reflect the user's
     experience of this schedule -- it didn't exist back
     then.
     */
    NSDate *beginningOfTime = self.systemDate.startOfDay;

    if (schedule.startsOn == nil)
    {
        schedule.startsOn = beginningOfTime;
    }


    /*
     Effective start date = start date + delay.  Then round to midnight that
     morning.  See this -compute method for details.
     */
    schedule.effectiveStartDate = [schedule computeDelayedStartDateFromDate: schedule.startsOn];


    /*
     Effective end date:  the end date + the expiration period, then round to 
     the end of that day.  See this -compute method for details.
     */
    schedule.effectiveEndDate = [schedule computeExpirationDateForScheduledDate: schedule.endsOn];


    //
    // Creating Tasks
    //
    NSArray *tasks = scheduleData [kScheduleListOfTasksKey];

    for (NSDictionary *taskData in tasks)
    {
        APCTask *task = [self createOrUpdateTaskFromJsonData: taskData
                                                   inContext: context];
        if (task)
        {
            /*
             This next method has a funky name because it's auto-generated
             by Xcode's "Editor > Create Managed Object Subclass" command,
             which (completely reasonably) doesn't seem to understand
             English plurals.  This should have been named -addOneTaskObject.
             Instead, its name means, "add one object to the "tasks"
             relationship."
             */
            [schedule addTasksObject: task];
        }
    }


    //Run some custom patching code to fix startOn dates for selected tasks
    [self patchSchedule:schedule];
    
    //
    // Done!
    //
    return schedule;
}

/**
 When we get data from a file or from the server, we first
 convert it to a set of dictionaries.  Each dictionary
 contains one Schedule.  That Schedule contains a list of
 the Tasks the schedule should manage.  Then we loop
 through those Schedules, creating each one.  Within that
 "create schedule" method, we then loop through all the
 Tasks it's supposed to manage, and create each of THOSE.
 This method does that part: creates a single Task, when
 we're looping through the list of tasks attached to
 inbound schedule data.
 */
- (APCTask *) createOrUpdateTaskFromJsonData: (NSDictionary *) taskData
                                   inContext: (NSManagedObjectContext *) context
{
    APCTask  *task              = nil;
    NSString *taskId            = [self nilIfNull: taskData [kTaskIDKey]];
    NSNumber *taskVersionNumber = [self nilIfNull: taskData [kTaskVersionNumberKey]];

    NSError *errorFindingExistingTask = nil;

    task = [self taskWithId: taskId
              versionNumber: taskVersionNumber
                  inContext: context
             returningError: & errorFindingExistingTask];

    if (task == nil)
    {
        task = [APCTask newObjectForContext: context];
        task.taskID = taskId;
        task.taskVersionNumber = taskVersionNumber;
    }

    [self updateTask: task
            withData: taskData];

    return task;
}

- (void) updateTask: (APCTask *) task
           withData: (NSDictionary *) taskData
{
    //
    // Update the task with potentially new data
    // (or add it for the first time, if we're creating a task).
    //
    task.taskHRef                   = [self nilIfNull: taskData [kTaskUrlKey]];                     // Sage-only?
    task.taskTitle                  = [self nilIfNull: taskData [kTaskTitleKey]];                   // sage and us
    task.sortString                 = [self nilIfNull: taskData [kTaskSortStringKey]];              // us-only, for now
    task.taskClassName              = [self nilIfNull: taskData [kTaskClassNameKey]];               // sage and us, because we add to sage
    task.taskCompletionTimeString   = [self nilIfNull: taskData [kTaskCompletionTimeStringKey]];    // us-only?
    task.taskContentFileName        = [self nilIfNull: taskData [kTaskFileNameKey]];                // us-only?
    task.taskIsOptional             = [self nilIfNull: taskData [kTaskIsOptionalKey]];              // us for now, Sage eventually?


    if ([task.taskTitle stringByTrimmingCharactersInSet: [NSCharacterSet whitespaceAndNewlineCharacterSet]].length == 0)
    {
        APCLogDebug (@"\n-------------\nWARNING!  About to create a Task with an empty title!  taskData and task are:  \n%@\n%@\n----------------", taskData, task);
        NSLog (@"");
    }

    /*
     STRONGLY SUGGESTED: move this to the individual Task
     view controllers.  This section actually compiles and
     serializes the content of the survey file.  But it's
     just JSON, and can easily and safely be loaded later;
     we don't have to store it CoreData.  We probably *do*
     want to *verify* that it can indeed be compiled.
     */
    if (task.taskContentFileName)
    {
        // This method spews errors as needed.
        id <ORKTask> survey = [self surveyFromFileBaseName: task.taskContentFileName];

        if (survey)
        {
            task.rkTask = survey;
        }
    }
}

- (APCTask *) taskWithId: (NSString *) taskId
           versionNumber: (NSNumber *) versionNumber
               inContext: (NSManagedObjectContext *) context
          returningError: (NSError * __autoreleasing *) errorToReturn
{
    APCTask *task = nil;
    NSError *localError = nil;
    NSFetchRequest *searchForThisExactTask = [APCTask requestWithPredicate: [NSPredicate predicateWithFormat: @"%K == %@ && %K == %@",
                                                                             NSStringFromSelector (@selector (taskID)),
                                                                             taskId,
                                                                             NSStringFromSelector (@selector (taskVersionNumber)),
                                                                             versionNumber
                                                                             ]];

    NSError *errorSearchingForTasks = nil;
    NSArray *possibleCopiesOfThisTask = [context executeFetchRequest: searchForThisExactTask
                                                               error: & errorSearchingForTasks];

    /*
        To test this check change the condition to check for non-nil
     */
    if (! possibleCopiesOfThisTask)
    {
        localError = [NSError errorWithCode: APCErrorSearchingForTaskWithIDCode
                                     domain: APCErrorDomainLoadingTasksAndSchedules
                              failureReason: APCErrorSearchingForTaskWithIDReason
                         recoverySuggestion: APCErrorSearchingForTasksWithIDSuggestion
                                nestedError: errorSearchingForTasks];
    }
    else if (possibleCopiesOfThisTask.count == 0)
    {
        // It actually doesn't exist.  No problem.
    }
    else if (possibleCopiesOfThisTask.count == 1)
    {
        // Whew.  Perfect.
        task = possibleCopiesOfThisTask.firstObject;
    }
    else  // more than one task with this ID and version
    {
        /*
         This should literally never happen, because of this "if" block.
         What do we we if it does?  For now, yelp and continue.
         */
        NSString *nameOfTaskIDField             = NSStringFromSelector (@selector (taskID));
        NSString *nameOfTaskVersionField        = NSStringFromSelector (@selector (taskVersionNumber));

        NSError  *whoopsTooManyTasksWithThisID  = [NSError errorWithCode: APCErrorMoreThanOneTaskWithIdAndVersionCode
                                                                  domain: APCErrorDomainLoadingTasksAndSchedules
                                                           failureReason: APCErrorMoreThanOneTaskWithIdAndVersionReason
                                                      recoverySuggestion: APCErrorMoreThanOneTaskWithIdAndVersionSuggestion
                                                         relatedFilePath: nil
                                                              relatedURL: nil
                                                             nestedError: nil
                                                           otherUserInfo: @{ nameOfTaskIDField      : [self nullIfNil: taskId],
                                                                             nameOfTaskVersionField : [self nullIfNil: versionNumber]
                                                                             }];

        APCLogError2 (whoopsTooManyTasksWithThisID);

        // ...so this is undefined, kinda:
        task = possibleCopiesOfThisTask.firstObject;

        // ...and we're about to return an error when we're also
        // returning a valid object, which means the calling
        // method won't expect this.  In progress.
        localError = whoopsTooManyTasksWithThisID;
    }

    if (errorToReturn != nil)
    {
        * errorToReturn = localError;
    }

    return task;
}

- (id <ORKTask>) surveyFromFileBaseName: (NSString *) surveyContentFileBaseName
{
    id <ORKTask> rkSurvey = nil;

    NSString *surveyFilePath = [[NSBundle mainBundle] pathForResource: surveyContentFileBaseName
                                                     ofType: kAPCFileExtension_JSON];

    if (! surveyFilePath)
    {
        NSString *fullFileName = [NSString stringWithFormat: @"%@.%@", surveyContentFileBaseName, kAPCFileExtension_JSON];

        NSError *errorFindingSurveyFile = [NSError errorWithCode: APCErrorCouldntFindSurveyFileCode
                                                          domain: APCErrorDomainLoadingTasksAndSchedules
                                                   failureReason: APCErrorCouldntFindSurveyFileReason
                                              recoverySuggestion: APCErrorCouldntFindSurveyFileSuggestion
                                                 relatedFilePath: fullFileName
                                                      relatedURL: nil
                                                     nestedError: nil];

        APCLogError2 (errorFindingSurveyFile);
    }

    else
    {
        NSError *errorLoadingSurveyFile = nil;
        NSData *jsonData = [NSData dataWithContentsOfFile: surveyFilePath
                                                  options: 0
                                                    error: & errorLoadingSurveyFile];

        if (! jsonData)
        {
            NSError *error = [NSError errorWithCode: APCErrorLoadingSurveyFileCode
                                             domain: APCErrorDomainLoadingTasksAndSchedules
                                      failureReason: APCErrorLoadingSurveyFileReason
                                 recoverySuggestion: APCErrorLoadingSurveyFileSuggestion
                                        nestedError: errorLoadingSurveyFile];
            
            APCLogError2 (error);
        }

        else
        {
            NSError *errorParsingSurveyContent = nil;
            NSDictionary *surveyContent = [NSJSONSerialization JSONObjectWithData: jsonData
                                                                          options: 0
                                                                            error: & errorParsingSurveyContent];
            if (! surveyContent)
            {
                NSError *error = [NSError errorWithCode: APCErrorParsingSurveyContentCode
                                                 domain: APCErrorDomainLoadingTasksAndSchedules
                                          failureReason: APCErrorParsingSurveyContentReason
                                     recoverySuggestion: APCErrorParsingSurveyContentSuggestion
                                            nestedError: errorParsingSurveyContent];
                
                APCLogError2 (error);
            }

            else
            {
                @try
                {
                    id manager = SBBComponent(SBBSurveyManager);
                    SBBSurvey *survey = [[manager objectManager] objectFromBridgeJSON: surveyContent];
                    rkSurvey = [APCTask rkTaskFromSBBSurvey: survey];
                }
                @catch (NSException *exception)
                {
                    NSError *error = [NSError errorWithCode: APCErrorLoadingNativeBridgeSurveyObjectCode
                                                     domain: APCErrorDomainLoadingTasksAndSchedules
                                              failureReason: APCErrorLoadingNativeBridgeSurveyObjectReason
                                         recoverySuggestion: APCErrorLoadingNativeBridgeSurveyObjectSuggestion
                                            relatedFilePath: surveyFilePath
                                                 relatedURL: nil
                                                nestedError: nil
                                              otherUserInfo: @{ @"exception": exception,
                                                                @"stackTrace": exception.callStackSymbols }];

                    APCLogError2 (error);
                }
                @finally
                {

                }
            }
        }
    }

    return rkSurvey;
}




// =========================================================
#pragma mark - IV. MANAGING POTENTIAL AND SCHEDULED TASKS -
// =========================================================

/**
 Generates a new Scheduled Task, when the user is about to
 view it for the first time.

 Not yet sure what threads this is going to run on.
 Ideally, all CoreData operations will happen in the
 background on well-known queues.  Unfortunately, a vast
 chunk of the infrastructure of this project does stuff on
 the main thread.  and I'm trying to disturb as little as
 possible as I make vast changes to the way it schedules
 tasks.
 */
- (APCScheduledTask *) createScheduledTaskFromPotentialTask: (APCPotentialTask *) potentialTask
{
    APCSchedule *schedule           = potentialTask.schedule;
    NSDate *startDate               = potentialTask.scheduledAppearanceDate;
    NSDate *endDate                 = [schedule computeExpirationDateForScheduledDate: startDate];
    APCScheduledTask *scheduledTask = [APCScheduledTask newObjectForContext: self.scheduleMOC];
    scheduledTask.generatedSchedule = potentialTask.schedule;
    scheduledTask.task              = potentialTask.task;
    scheduledTask.startOn           = startDate;
    scheduledTask.endOn             = endDate;

    NSError *errorSavingTask        = nil;
    BOOL savedSuccessfully          = [scheduledTask saveToPersistentStore: & errorSavingTask];

    if (! savedSuccessfully)
    {
        NSError *error = [NSError errorWithCode: APCErrorSavingToPeristentStoreCode
                                         domain: APCErrorDomainLoadingTasksAndSchedules
                                  failureReason: APCErrorSavingToPeristentStoreReason
                             recoverySuggestion: APCErrorSavingToPeristentStoreSuggestion
                                    nestedError: errorSavingTask];

        APCLogError2 (error);

        [self deleteScheduledTask: scheduledTask];

        scheduledTask = nil;
    }


    /*
     Clear the taskGroup cache, so UIs (and anything else
     depending on the cached taskGroups) draw correctly.
     This operation is thread-safe.
     */
    [self clearTaskGroupCache];


    return scheduledTask;
}

/**
 Not yet sure what threads this is going to run on.
 Ideally, all CoreData operations will happen in the
 background on well-known queues.  Unfortunately, a vast
 chunk of the infrastructure of this project does stuff on
 the main thread, and I'm trying to disturb as little as
 possible as I make vast changes to the way it schedules
 tasks.
 */
- (void) deleteScheduledTask: (APCScheduledTask *) scheduledTask
{
    NSError *errorDeleting = nil;
    [self.scheduleMOC deleteObject: scheduledTask];

    BOOL deletedSuccessfully = [scheduledTask saveToPersistentStore: & errorDeleting];

    if (! deletedSuccessfully)
    {
        NSError* error = [NSError errorWithCode: APCErrorDeletingTaskCode
                                         domain: APCErrorDomainLoadingTasksAndSchedules
                                  failureReason: APCErrorDeletingTaskReason
                             recoverySuggestion: APCErrorDeletingTaskSuggestion
                                    nestedError: errorDeleting];

        APCLogError2 (error);
    }

    /*
     Clear the taskGroup cache, so UIs (and anything else
     depending on the cached taskGroups) draw correctly.
     This operation is thread-safe.
     */
    [self clearTaskGroupCache];
}




// =========================================================
#pragma mark - V. UTILITIES -
// =========================================================




// ---------------------------------------------------------
#pragma mark - Replying to the method who called me
// ---------------------------------------------------------

/**
 A local utility function, which checks for nil in both the
 callbackBlock and the queue before queueing that block on
 that queue, solely so I don't have to repeat those "if"
 clauses everywhere I do this.
 */
- (void) performFetchAndLoadCallback: (APCSchedulerCallbackForFetchAndLoadOperations) callbackBlock
                             onQueue: (NSOperationQueue *) queue
                        sendingError: (NSError *) error
{
    if (queue != nil && callbackBlock != nil)
    {
        [queue addOperationWithBlock: ^{
            callbackBlock (error);
        }];
    }
}



// ---------------------------------------------------------
#pragma mark - Wrapper around system date
// ---------------------------------------------------------

/**
 Internal method that returns the fakeSystemDate, if it's
 been set and if we're in debug mode, or the real system
 date otherwise.
 */
- (NSDate *) systemDate
{
    NSDate *date = nil;

    if ([APCUtilities isInDebuggingMode] && self.fakeSystemDate != nil)
    {
        date = self.fakeSystemDate;
    }
    else
    {
        date = [NSDate date];
    }

    return date;
}

- (void) clearFakeSystemDate
{
    /*
     queue this along with all other operations on our
     internal queue.
     */
    [self.queryQueue addOperationWithBlock:^{

        self.fakeSystemDate = nil;
        
    }];
}



// ---------------------------------------------------------
#pragma mark - Default Values
// ---------------------------------------------------------

/**
 I'm hard-coding this because it serves a purpose: this
 *is* the list of constants.

 I'd prefer to get these from a file.  However, the JSON
 parser we're using can't handle comments in a JSON file,
 and, to me, those comments are crucial to our
 understanding why we've chosen the settings we did.  So
 I'll put 'em here, where we can comment them cleanly.
 */
- (NSDictionary *) defaultScheduleValues
{
    NSNull *null = [NSNull null];

    return @{
             kScheduleTypeKey               : kScheduleTypeValueOnce,
             kScheduleStringKey             : null,
             kTaskIDKey                     : null,
             kScheduleExpiresKey            : null,
             kScheduleDelayKey              : null,
             kScheduleStartDateKey          : null,
             kScheduleEndDateKey            : null,
             };
}

- (NSDictionary *) defaultTaskValues
{
    return @{};
}



// ---------------------------------------------------------
#pragma mark - Are we talkin' to the server?
// ---------------------------------------------------------

- (BOOL) isServerDisabled
{
    APCAppDelegate *app = [APCAppDelegate sharedAppDelegate];
    BOOL result = app.dataSubstrate.parameters.bypassServer;

#if DEVELOPMENT
    result = YES;
#endif

    return result;
}



// ---------------------------------------------------------
#pragma mark - The TaskGroup Cache
// ---------------------------------------------------------

/*
 The three methods in this section use the "@synchronized"
 keyword.  This means precisely the following:

 -  They read and change the same array.

 -  They are called by a couple of methods from at least
    2 threads, and are frequently called at the same time.
 
 -  Each change to that array takes several steps.
    Those steps have to happen together if we want the
    array and its contents to be make sense.
 
 -  The app has SOME sort of architectural design flaw.
 
 If we designed things correctly, we should never need to
 use @synchronized. The fact that we need it reveals an
 architectural design problem. It's not a bug -- the app
 works -- but it's something we should look at. This cache
 exists because some of our CoreData accessor methods are
 called frequently, and from the main thread. This
 shouldn't happen. Instead, they should be redesigned to
 request information from CoreData and EXPECT that call to
 take forever. They should go about their business, and
 only later, when a response comes back from CoreData,
 should they repaint the screen (or do whatever else they
 had to do) with the newly retrieved information.
 Unfortunately, as I write this, that's not a set of bugs I
 have to fix to solve the problems I'm currently working on
 (centralizing all the math for doing Scheduling
 calculations). So the @synchronized keyword lets me make
 the main and background threads "play nice" together.

 A brief tutorial on how to use @synchronized:

 Here's a real-world analogy of when we'd use the
 "@sychronized" keyword:  Taking out the trash, at home,
 in your kitchen.

 Let's say your normal procedure for taking out the trash
 includes (a) pulling the old trash bag out of the trash
 can, and (b) putting a new trash bag into the trash can.
 There are a bunch of other steps, like realizing the bag
 is full beforehand, and walking it down to the Dumpster
 afterwards. But steps (a) and (b) show a crucial point.
 Before you pull the old bag out (step a), or after you put
 the new bag in (step b), anyone can put stuff in the trash
 can. But if someone were to pop into the kitchen and put
 something into the trash can during those crucial few
 seconds between when you'd taken the old bag out and put
 in the new bag, then the trash can would get smelly and
 messy. So, in real life, if you're in the middle of that
 process, and someone comes in to put throw something away,
 you might tell 'em: "Hey, wait a sec, lemme put the new
 bag in there, first." The @synchronized keyword does that:
 it tells other threads to "hang on a sec" while you finish
 a couple of things that *have* to happen at the same time.

 For that same reason, the stuff you do inside the
 @synchronized block needs to be as short and fast as
 possible. We wouldn't want to take out the trash bag, tie
 it off, and traipse down to the end of the apartment
 complex to throw it away, stopping to talk to the friendly
 neighbors, BEFORE putting the new trash bag in -- if other
 people in your family might need to use the trash can
 during those couple of minutes. Likewise, stuff in the
 @synchronized block should be as short and uncomplicated
 as possible. It shouldn't call other methods, or have
 dependencies on anything else in the system.
 */

- (NSArray *) cachedTaskGroupsForDayOfDate: (NSDate *) date
                    forTasksMatchingFilter: (NSPredicate *) taskFilter
{
    APCTaskGroupCacheEntry *foundCacheEntry = nil;

    @synchronized (self.taskGroupCacheMutex)
    {
        for (APCTaskGroupCacheEntry *cacheEntry in self.taskGroupCache)
        {
            BOOL bothTaskFiltersAreNil          = taskFilter == nil && cacheEntry.taskFilter == nil;
            BOOL taskFiltersHaveSameDescription = [taskFilter.description isEqualToString: cacheEntry.taskFilter.description];

            if ([date.startOfDay isEqualToDate: cacheEntry.date.startOfDay] &&
                (bothTaskFiltersAreNil || taskFiltersHaveSameDescription))
            {
                foundCacheEntry = cacheEntry;
                break;
            }
        }
    }

    return foundCacheEntry.taskGroups;
}

- (void) cacheTaskGroups: (NSArray *) taskGroups
                 forDate: (NSDate *) date
               andFilter: (NSPredicate *) taskFilter
{
    @synchronized (self.taskGroupCacheMutex)
    {
        NSArray *cachedTaskGroups = [self cachedTaskGroupsForDayOfDate: date
                                                forTasksMatchingFilter: taskFilter];

        if (cachedTaskGroups == nil)
        {
            APCTaskGroupCacheEntry *cacheEntry = [[APCTaskGroupCacheEntry alloc] initWithDate: date
                                                                                   taskFilter: taskFilter
                                                                                   taskGroups: taskGroups];

            APCLogDebug (@"Caching task groups: %@", cacheEntry);

            [self.taskGroupCache addObject: cacheEntry];
        }
    }
}

- (void) clearTaskGroupCache
{
    @synchronized (self.taskGroupCacheMutex)
    {
        APCLogDebug (@"Clearing the task-group cache.");

        self.taskGroupCache = [NSMutableArray new];
    }
}



// ---------------------------------------------------------
#pragma mark - Utility Methods
// ---------------------------------------------------------

- (APCAppDelegate *) appDelegate
{
    return [APCAppDelegate sharedAppDelegate];
}

- (NSManagedObjectContext *) managedObjectContext
{
    return self.scheduleMOC;
}

/**
 Performs a "practical" version of "isEqual", returning YES if
 -  both objects are nil, or
 -  [object1 isEqual: object2]
 */
- (BOOL) object1: (id) object1
   equalsObject2: (id) object2
{
    return ((object1 == nil && object2 == nil) || [object1 isEqual: object2]);
}

/**
 Returns nil if the specified value is [NSNull null].
 Otherwise, returns the value itself.

 Used to extract values from an NSDictionary and treat them
 as "nil" when that was the actual intent.
 */
- (id) nilIfNull: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == [NSNull null])
    {
        outputValue = nil;
    }

    return outputValue;
}

/**
 Returns [NSNull null] if the specified value is
 [NSNull null], so that we can insert the specified item
 into a dictionary.  Otherwise, returns the value itself.
 */
- (id) nullIfNil: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == nil)
    {
        outputValue = [NSNull null];
    }

    return outputValue;
}

- (NSArray *) arrayByFindingCommonElementsInScheduleArray: (NSArray *) scheduleList1
                                         andScheduleArray: (NSArray *) scheduleList2
                              comparingObjectsUsingFields: (BOOL) shouldComparePointersNotFields
{
    //
    // For debugging:  sort them by title, so I can see what's going on.
    //
    scheduleList1 = [scheduleList1 sortedArrayUsingSelector: @selector (compareWithSchedule:)];
    scheduleList2 = [scheduleList2 sortedArrayUsingSelector: @selector (compareWithSchedule:)];

    NSMutableArray *result = [NSMutableArray new];
    NSMutableArray *shorterCopyOfList2 = [NSArray arrayWithArray: scheduleList2].mutableCopy;

    for (APCSchedule *schedule1 in scheduleList1)
    {
        for (APCSchedule *schedule2 in shorterCopyOfList2)
        {
            BOOL theyreTheSame = [self schedule: schedule1
                         isEquivalentToSchedule: schedule2
                    comparingObjectsUsingFields: shouldComparePointersNotFields];

            if (theyreTheSame)
            {
                [result addObject: schedule1];
                [shorterCopyOfList2 removeObject: schedule2];
                break;
            }
        }
    }

    return result;
}

- (NSArray *) arrayByRemovingElementsInScheduleArray: (NSArray *) stuffToRemove
                                   fromScheduleArray: (NSArray *) stuffToKeep
                         comparingObjectsUsingFields: (BOOL) shouldCompareFieldsNotPointers
{

    //
    // For debugging:  sort them by title, so I can see what's going on.
    //
    stuffToRemove = [stuffToRemove sortedArrayUsingSelector: @selector (compareWithSchedule:)];
    stuffToKeep   = [stuffToKeep sortedArrayUsingSelector: @selector (compareWithSchedule:)];

    NSMutableArray *result = [NSMutableArray new];

    for (APCSchedule *scheduleToKeep in stuffToKeep)
    {
        BOOL found = NO;

        for (APCSchedule *scheduleToRemove in stuffToRemove)
        {
            BOOL theyreTheSame = [self schedule: scheduleToKeep
                         isEquivalentToSchedule: scheduleToRemove
                    comparingObjectsUsingFields: shouldCompareFieldsNotPointers];

            if (theyreTheSame)
            {
                found = YES;
                break;
            }
        }

        if (! found)
        {
            [result addObject: scheduleToKeep];
        }
    }
    
    return result;
}

- (NSArray *) arrayByRemovingElementsInArray: (NSArray *) stuffToRemove
                                   fromArray: (NSArray *) stuffToKeep
                comparingObjectsUsingIsEqual: (BOOL) shouldCompareEqualityNotPointers
{
    NSMutableArray *result = [NSMutableArray new];

    for (NSObject *thingyToKeep in stuffToKeep)
    {
        BOOL found = NO;

        for (NSObject *thingyToRemove in stuffToRemove)
        {
            BOOL theyreTheSame = (shouldCompareEqualityNotPointers ?
                                  [thingyToKeep isEqual: thingyToRemove] :
                                  thingyToKeep == thingyToRemove);

            if (theyreTheSame)
            {
                found = YES;
                break;
            }
        }

        if (! found)
        {
            [result addObject: thingyToKeep];
        }
    }
    
    return result;
}

- (BOOL)               schedule: (APCSchedule *) schedule1
         isEquivalentToSchedule: (APCSchedule *) schedule2
    comparingObjectsUsingFields: (BOOL) shouldCompareFieldsNotPointers
{
    BOOL schedulesAreEquivalent = NO;

    if (! shouldCompareFieldsNotPointers)
    {
        schedulesAreEquivalent = (schedule1 == schedule2);
    }
    else
    {
        BOOL propertiesAreEqual = (
                                   [self object1: schedule1.scheduleSource      equalsObject2: schedule2.scheduleSource]    &&      // server, disk, glucose log, etc.
                                   [self object1: schedule1.scheduleType        equalsObject2: schedule2.scheduleType]      &&      // one-time, cron-based, interval-based
                                   [self object1: schedule1.effectiveEndDate    equalsObject2: schedule2.effectiveEndDate]  &&
                                   [self object1: schedule1.delay               equalsObject2: schedule2.delay]             &&      // delay before first instance shows up on calendar
                                   [self object1: schedule1.expires             equalsObject2: schedule2.expires]           &&      // delay before each instance vanishes from calendar
                                   [self object1: schedule1.maxCount            equalsObject2: schedule2.maxCount]          &&      // max number of occurrences on calendar
                                   [self object1: schedule1.notes               equalsObject2: schedule2.notes]             &&
                                   [self object1: schedule1.scheduleString      equalsObject2: schedule2.scheduleString]    &&      // the cron expression
                                   [self object1: schedule1.shouldRemind        equalsObject2: schedule2.shouldRemind]      &&
                                   [self object1: schedule1.reminderMessage     equalsObject2: schedule2.reminderMessage]   &&
                                   [self object1: schedule1.reminderOffset      equalsObject2: schedule2.reminderOffset]    &&
                                   [self object1: schedule1.interval            equalsObject2: schedule2.interval]          &&      // time between appearances, like "3 months"
                                   [self object1: schedule1.timesOfDay          equalsObject2: schedule2.timesOfDay]        &&      // list of times of day, if using intervals

                                   true     // leave this at the end, to make it easier to rearrange the lines above
                                   );

        if (propertiesAreEqual &&
            (schedule1.tasks.count == schedule2.tasks.count) &&
            (schedule1.tasks.count > 0))
        {
            /*
             Up to here, they're identical.  Past this point, we'll
             look for something NOT different, and set this to NO
             if found:
             */
            schedulesAreEquivalent = YES;

            /*
             We have the same number of tasks.  Let's sort both lists of tasks
             by ID and version, and then walk through them in order.  If we find
             any differences, one of the tasks is different from the other, which
             is all we need to know.
             
             Sort them using an array of sort descriptors I declared at the top
             of this file.  We might call this method hundreds of times for a given
             schedule download.  We won't do that OFTEN, but there's no reason to
             keep reallocating those sort descriptors every time that happens.
             */
            NSArray *myTasks    = [schedule1.tasks.allObjects sortedArrayUsingDescriptors: [APCTask defaultSortDescriptors]];
            NSArray *otherTasks = [schedule2.tasks.allObjects sortedArrayUsingDescriptors: [APCTask defaultSortDescriptors]];

            for (NSUInteger taskIndex = 0; taskIndex < myTasks.count; taskIndex ++)
            {
                APCTask *myTask = myTasks [taskIndex];
                APCTask *otherTask = otherTasks [taskIndex];

                if (! [self object1: myTask.taskID            equalsObject2: otherTask.taskID] ||
                    ! [self object1: myTask.taskVersionNumber equalsObject2: otherTask.taskVersionNumber])
                {
                    schedulesAreEquivalent = NO;
                    break;
                }
            }
        }
    }

    return schedulesAreEquivalent;
}

/** There are some very similar method(s) in ScheduleIntervalEnumerator. */
- (NSString *) serializedTimesOfDayStringFromISO8601TimesOfDayInArray: (NSArray *) timesOfDay
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: @"en_US_POSIX"];

    NSArray *legalFormats = @[@"H",
                              @"HH",
                              @"HH:mm",
                              @"HH:mm:SS",
                              @"HH:mm:SS.sss"
                              ];

    NSString *result = nil;
    NSMutableArray *arrayOfValidStrings = [NSMutableArray new];

    if (timesOfDay != nil && [timesOfDay isKindOfClass: [NSArray class]])
    {
        for (id thingy in timesOfDay)
        {
            NSString *inboundTimeString = nil;

            /*
             Allow integers as times of day (3 = 3am, 14 =
             2pm, etc.) The spec only requests ISO8601
             strings, but I think this will make life
             easier and equally practical, and it doesn't
             cost us much.
             */
            if ([thingy isKindOfClass: [NSNumber class]])
            {
                NSNumber *value = thingy;
                NSUInteger intValue = value.integerValue;
                float floatValue = value.floatValue;
                if (floatValue == (float) intValue &&
                    intValue >= kAPCTimeFirstLegalISO8601HourOfDay &&
                    intValue <= kAPCTimeLastLegalISO8601HourOfDay)
                {
                    inboundTimeString = value.stringValue;
                }
            }

            else if ([thingy isKindOfClass: [NSString class]])
            {
                inboundTimeString = thingy;
            }

            else
            {
                // Ignore all other data types.
            }

            if (inboundTimeString != nil)
            {
                NSDate *date = nil;

                for (NSString *format in legalFormats)
                {
                    formatter.dateFormat = format;
                    date = [formatter dateFromString: inboundTimeString];

                    if (date != nil)
                    {
                        break;
                    }
                }

                if (date != nil)
                {
                    [arrayOfValidStrings addObject: inboundTimeString];
                }
            }
        }
    }

    result = [arrayOfValidStrings componentsJoinedByString: @"|"];

    if (result.length == 0)
    {
        result = nil;
    }

    return result;
}

- (NSArray *) deserializedArrayOfDurationsSinceMidnightFromISO8601TimesOfDayString: (NSString *) serializedTimesOfDayString
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: @"en_US_POSIX"];

    NSArray *legalFormats = @[@"H",
                              @"HH",
                              @"HH:mm",
                              @"HH:mm:SS",
                              @"HH:mm:SS.sss"
                              ];

    NSMutableArray *result = [NSMutableArray new];

    NSArray *iso8601TimeStrings = [serializedTimesOfDayString componentsSeparatedByString: @"|"];

    for (NSString *iso8601TimeString in iso8601TimeStrings)
    {
        NSDate *date = nil;

        for (NSString *format in legalFormats)
        {
            formatter.dateFormat = format;
            date = [formatter dateFromString: iso8601TimeString];

            if (date != nil)
            {
                break;
            }
        }

        if (date != nil)
        {
            NSDate *midnightOnThatDate = date.startOfDay;
            NSTimeInterval secondsSinceMidnight = [date timeIntervalSinceDate: midnightOnThatDate];
            [result addObject: @(secondsSinceMidnight)];
        }
    }

    if (result.count == 0)
    {
        result = nil;
    }

    return result;
}



-(void)patchSchedule:(APCSchedule*)schedule
{
    NSArray* taskIdsToPatch = [NSArray arrayWithObjects:@"MileStone-234234-d731-4372-ba30-a5859f655297-v1",
                               @"MileStone-234234-d731-4372-ba30-a5859f655297-v2",
                               @"Feedback-65756-d731-4372-ba30-a5859f655297-v1",
                               @"Feedback-4564523-d731-4372-ba30-a5859f655297-v2",@"", nil];
    
    NSPredicate *filterForRequiredTasks = [NSPredicate predicateWithFormat: @"%K in %@",
                                           NSStringFromSelector(@selector(taskID)),
                                           taskIdsToPatch];
    
    NSSet* filteredTasks = [schedule.tasks filteredSetUsingPredicate:filterForRequiredTasks];
    

    //Fixed start dates for schedules with tasks we want to patch
    if([filteredTasks count] > 0){
        NSDate* consentSignatureDate = self.dataSubstrate.currentUser.consentSignatureDate;
        
        if (consentSignatureDate == nil)
        {
            // Same logic as in -[APCUser estimatedConsentDate]:
            // if we can't get the user's consent date, try a
            // series of best guesses, ending with today's date.
            consentSignatureDate = [APCUser proxyForConsentDate];
            
            // Should truly never happen, but:
            if (consentSignatureDate == nil)
            {
                consentSignatureDate = [NSDate date];
            }
        }
        
        schedule.startsOn = consentSignatureDate;
        schedule.effectiveStartDate = [schedule computeDelayedStartDateFromDate: schedule.startsOn];
        schedule.effectiveEndDate = [schedule computeExpirationDateForScheduledDate: schedule.endsOn];
    }
}

@end

















